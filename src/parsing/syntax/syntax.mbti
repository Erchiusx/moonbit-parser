// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/parser/parsing/syntax"

import(
  "moonbitlang/core/list"
  "moonbitlang/parser/parsing/syntax_types"
)

// Values
fn arrow_fn_param_to_expr(ArrowFnParam) -> Expr

fn binder_to_expr(Binder) -> Expr

fn bracket_loc(Expr) -> @syntax_types.Location

fn desugar_array_augmented_set(@syntax_types.Location, Var, Expr, Expr, Expr) -> Expr

fn desugar_array_get(loc~ : @syntax_types.Location, Expr, Expr) -> Expr

fn desugar_array_set(loc~ : @syntax_types.Location, Expr, Expr, Expr) -> Expr

fn label_to_expr(loc~ : @syntax_types.Location, Label) -> Expr

fn label_to_pat(loc~ : @syntax_types.Location, Label) -> Pattern

fn make_alias_pattern(loc~ : @syntax_types.Location, Pattern, Binder) -> Pattern

fn make_array_expr(loc~ : @syntax_types.Location, @list.T[SpreadableElem]) -> Expr

fn make_arrow_fn(@list.T[(ArrowFnParam, Type?)], Expr, loc~ : @syntax_types.Location) -> Func

fn make_assign_opt(loc~ : @syntax_types.Location, Expr, Expr) -> Expr?

fn make_attribute(loc~ : @syntax_types.Location, id~ : String, dot_id~ : String?, raw_payload~ : String) -> @syntax_types.Attribute

fn make_augmented_assign_opt(loc~ : @syntax_types.Location, Var, Expr, Expr) -> Expr?

fn make_constant_expr(loc~ : @syntax_types.Location, Constant) -> Expr

fn make_constant_pattern(loc~ : @syntax_types.Location, Constant) -> Pattern

fn make_constr_pattern(loc~ : @syntax_types.Location, Constructor, @list.T[ConstrPatArg]?, Bool) -> Pattern

fn make_double(String) -> Constant

fn make_field_def(loc~ : @syntax_types.Location, Label, Expr, Bool) -> FieldDef

fn make_field_pat(loc~ : @syntax_types.Location, Label, Pattern, Bool) -> FieldPat

fn make_float(String) -> Constant

fn make_ident_expr(loc~ : @syntax_types.Location, Var) -> Expr

fn make_int(String) -> Constant

fn make_interp_expr(loc~ : @syntax_types.Location, Array[InterpolationComponent]) -> Expr

fn make_interps(Array[InterpolationComponent]) -> @list.T[InterpElem]

fn make_legacy_type_alias(Type, Type, attrs~ : @list.T[@syntax_types.Attribute], vis~ : Visibility, deriving~ : @list.T[DerivingDirective], loc~ : @syntax_types.Location, doc~ : @syntax_types.DocString) -> TypeDecl?

fn make_option_type(loc~ : @syntax_types.Location, constr_loc~ : @syntax_types.Location, Type) -> Type

fn make_record_expr(loc~ : @syntax_types.Location, trailing~ : TrailingMark, TypeName?, @list.T[FieldDef]) -> Expr

fn make_tuple_expr(loc~ : @syntax_types.Location, @list.T[Expr]) -> Expr

fn make_tuple_pattern(loc~ : @syntax_types.Location, @list.T[Pattern]) -> Pattern

fn make_tuple_type(loc~ : @syntax_types.Location, @list.T[Type]) -> Type

fn make_uminus(loc~ : @syntax_types.Location, String, Expr) -> Expr

fn make_unot(loc~ : @syntax_types.Location, Expr) -> Expr

fn make_uplus(loc~ : @syntax_types.Location, String, Expr) -> Expr

let no_location : @syntax_types.Location

// Types and methods
pub(all) enum Accessor {
  Label(Label)
  Index(tuple_index~ : Int, loc~ : @syntax_types.Location)
  Newtype(loc~ : @syntax_types.Location)
}
impl ToJson for Accessor

pub(all) struct AliasTarget {
  binder : Binder
  target : Label?
}
impl ToJson for AliasTarget

pub(all) enum ApplyAttr {
  NoAttr
  Exclamation
  Question
}
impl ToJson for ApplyAttr

pub(all) struct Argument {
  value : Expr
  kind : ArgumentKind
}
impl ToJson for Argument

pub(all) enum ArgumentKind {
  Positional
  Labelled(Label)
  LabelledPun(Label)
  LabelledOption(label~ : Label, question_loc~ : @syntax_types.Location)
  LabelledOptionPun(label~ : Label, question_loc~ : @syntax_types.Location)
}
impl ToJson for ArgumentKind

pub(all) enum ArrayPattern {
  Pattern(Pattern)
  StringSpread(String)
  BytesSpread(String)
  ConstSpread(binder~ : Binder, pkg~ : String?, loc~ : @syntax_types.Location)
}
impl ToJson for ArrayPattern

pub(all) enum ArrayPatterns {
  Closed(@list.T[ArrayPattern])
  Open(@list.T[ArrayPattern], @list.T[ArrayPattern], DotDotBinder)
}
impl ToJson for ArrayPatterns

pub(all) enum ArrowFnParam {
  Named(Binder)
  Unnamed(@syntax_types.Location)
}

pub(all) struct Binder {
  name : String
  loc : @syntax_types.Location
}
impl ToJson for Binder

pub(all) struct Case {
  pattern : Pattern
  guard_ : Expr?
  body : Expr
}
impl ToJson for Case

pub(all) enum Constant {
  Bool(Bool)
  Byte(String)
  Bytes(String)
  Char(String)
  Int(String)
  Int64(String)
  UInt(String)
  UInt64(String)
  Float(String)
  Double(String)
  String(String)
  BigInt(String)
}
impl ToJson for Constant

pub(all) struct ConstrDecl {
  name : ConstrName
  args : @list.T[ConstrParam]?
  tag : (String, @syntax_types.Location)?
  loc : @syntax_types.Location
  doc : @syntax_types.DocString
}
impl ToJson for ConstrDecl

pub(all) struct ConstrId {
  id : LongIdent
  loc : @syntax_types.Location
}
impl ToJson for ConstrId

pub(all) struct ConstrName {
  name : String
  loc : @syntax_types.Location
}
impl ToJson for ConstrName

pub(all) struct ConstrParam {
  ty : Type
  mut_ : Bool
  label : Label?
}
impl ToJson for ConstrParam

pub(all) struct ConstrPatArg {
  pat : Pattern
  kind : ArgumentKind
}
impl ToJson for ConstrPatArg

pub(all) struct Constructor {
  name : ConstrName
  extra_info : ConstructorExtraInfo
  loc : @syntax_types.Location
}
impl ToJson for Constructor

pub(all) enum ConstructorExtraInfo {
  TypeName(TypeName)
  Package(String)
  NoExtraInfo
}
impl ToJson for ConstructorExtraInfo

pub(all) enum DeclBody {
  DeclBody(local_types~ : @list.T[LocalTypeDecl], expr~ : Expr)
  DeclStubs(FuncStubs)
}
impl ToJson for DeclBody

pub(all) struct DerivingDirective {
  type_name : TypeName
  args : @list.T[Argument]
  loc : @syntax_types.Location
}
impl ToJson for DerivingDirective

pub(all) enum DotDotBinder {
  Underscore
  NoBinder
  BinderAs(Binder)
  Binder(Binder)
}
impl ToJson for DotDotBinder

pub(all) enum EmbeddedCode {
  CodeString(String)
  CodeMultilineString(@list.T[String])
}
impl ToJson for EmbeddedCode

pub(all) enum ErrorType {
  ErrorType(ty~ : Type)
  DefaultErrorType(loc~ : @syntax_types.Location)
  NoErrorType
  Noraise(loc~ : @syntax_types.Location)
  MaybeError(ty~ : Type)
}
impl ToJson for ErrorType

pub(all) enum ExceptionDecl {
  NoPayload
  SinglePayload(Type)
  EnumPayload(@list.T[ConstrDecl])
}
impl ToJson for ExceptionDecl

pub(all) enum Expr {
  Apply(func~ : Expr, args~ : @list.T[Argument], attr~ : ApplyAttr, loc~ : @syntax_types.Location)
  Infix(op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @syntax_types.Location)
  Unary(op~ : Var, expr~ : Expr, loc~ : @syntax_types.Location)
  Array(exprs~ : @list.T[Expr], loc~ : @syntax_types.Location)
  ArraySpread(elems~ : @list.T[SpreadableElem], loc~ : @syntax_types.Location)
  ArrayGet(array~ : Expr, index~ : Expr, loc~ : @syntax_types.Location)
  ArrayGetSlice(array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @syntax_types.Location, loc~ : @syntax_types.Location)
  ArraySet(array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @syntax_types.Location)
  ArrayAugmentedSet(op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @syntax_types.Location)
  Constant(c~ : Constant, loc~ : @syntax_types.Location)
  MultilineString(elems~ : @list.T[MultilineStringElem], loc~ : @syntax_types.Location)
  Interp(elems~ : @list.T[InterpElem], loc~ : @syntax_types.Location)
  Constraint(expr~ : Expr, ty~ : Type, loc~ : @syntax_types.Location)
  Constr(constr~ : Constructor, loc~ : @syntax_types.Location)
  While(loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @syntax_types.Location)
  Function(func~ : Func, loc~ : @syntax_types.Location)
  Ident(id~ : Var, loc~ : @syntax_types.Location)
  If(cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @syntax_types.Location)
  Guard(cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @syntax_types.Location)
  Is(expr~ : Expr, pat~ : Pattern, loc~ : @syntax_types.Location)
  Defer(expr~ : Expr, body~ : Expr, loc~ : @syntax_types.Location)
  LetFn(name~ : Binder, func~ : Func, body~ : Expr, loc~ : @syntax_types.Location)
  LetRec(bindings~ : @list.T[(Binder, Func)], body~ : Expr, loc~ : @syntax_types.Location)
  LetAnd(bindings~ : @list.T[(Binder, Type?, Func)], body~ : Expr, loc~ : @syntax_types.Location)
  Let(pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @syntax_types.Location)
  Sequence(exprs~ : @list.T[Expr], last_expr~ : Expr, loc~ : @syntax_types.Location)
  Tuple(exprs~ : @list.T[Expr], loc~ : @syntax_types.Location)
  Record(type_name~ : TypeName?, fields~ : @list.T[FieldDef], trailing~ : TrailingMark, loc~ : @syntax_types.Location)
  RecordUpdate(type_name~ : TypeName?, record~ : Expr, fields~ : @list.T[FieldDef], loc~ : @syntax_types.Location)
  Field(record~ : Expr, accessor~ : Accessor, loc~ : @syntax_types.Location)
  Method(type_name~ : TypeName, method_name~ : Label, loc~ : @syntax_types.Location)
  DotApply(self~ : Expr, method_name~ : Label, args~ : @list.T[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @syntax_types.Location)
  As(expr~ : Expr, trait_~ : TypeName, loc~ : @syntax_types.Location)
  Mutate(record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @syntax_types.Location)
  Match(expr~ : Expr, cases~ : @list.T[Case], match_loc~ : @syntax_types.Location, using_~ : Label?, loc~ : @syntax_types.Location)
  LetMut(binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @syntax_types.Location)
  Pipe(lhs~ : Expr, rhs~ : Expr, loc~ : @syntax_types.Location)
  Assign(var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @syntax_types.Location)
  Hole(loc~ : @syntax_types.Location, kind~ : Hole)
  Return(return_value~ : Expr?, loc~ : @syntax_types.Location)
  Raise(err_value~ : Expr, loc~ : @syntax_types.Location)
  Unit(loc~ : @syntax_types.Location, faked~ : Bool)
  Break(arg~ : Expr?, label~ : Label?, loc~ : @syntax_types.Location)
  Continue(args~ : @list.T[Expr], label~ : Label?, loc~ : @syntax_types.Location)
  Loop(args~ : @list.T[Expr], body~ : @list.T[MultiArgCase], label~ : Label?, loop_loc~ : @syntax_types.Location, loc~ : @syntax_types.Location)
  For(binders~ : @list.T[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.T[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @syntax_types.Location)
  ForEach(binders~ : @list.T[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @syntax_types.Location)
  Try(body~ : Expr, catch_~ : @list.T[Case], catch_all~ : Bool, try_else~ : @list.T[Case]?, has_try~ : Bool, try_loc~ : @syntax_types.Location, catch_loc~ : @syntax_types.Location, else_loc~ : @syntax_types.Location, loc~ : @syntax_types.Location)
  TryOperator(body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @syntax_types.Location, loc~ : @syntax_types.Location)
  Map(elems~ : @list.T[MapExprElem], loc~ : @syntax_types.Location)
  Group(expr~ : Expr, group~ : Group, loc~ : @syntax_types.Location)
  StaticAssert(asserts~ : @list.T[StaticAssertion], body~ : Expr)
}
impl ToJson for Expr

pub(all) struct FieldDecl {
  name : FieldName
  ty : Type
  mut_ : Bool
  vis : Visibility
  loc : @syntax_types.Location
}
impl ToJson for FieldDecl

pub(all) struct FieldDef {
  label : Label
  expr : Expr
  is_pun : Bool
  loc : @syntax_types.Location
}
impl ToJson for FieldDef

pub(all) struct FieldName {
  label : String
  loc : @syntax_types.Location
}
impl ToJson for FieldName

pub(all) struct FieldPat {
  label : Label
  pattern : Pattern
  is_pun : Bool
  loc : @syntax_types.Location
}
impl ToJson for FieldPat

pub(all) enum FnKind {
  Lambda
  Matrix
  Arrow
}
impl ToJson for FnKind

pub(all) struct FunDecl {
  type_name : TypeName?
  name : Binder
  has_error : @syntax_types.Location?
  is_async : Bool
  decl_params : @list.T[Parameter]?
  params_loc : @syntax_types.Location
  quantifiers : @list.T[TypeVarBinder]
  return_type : Type?
  error_type : ErrorType
  vis : Visibility
  attrs : @list.T[@syntax_types.Attribute]
  mut doc : @syntax_types.DocString
}
impl ToJson for FunDecl

pub(all) enum Func {
  Lambda(parameters~ : @list.T[Parameter], params_loc~ : @syntax_types.Location, body~ : Expr, return_type~ : Type?, error_type~ : ErrorType, kind~ : FnKind, has_error~ : @syntax_types.Location?, is_async~ : Bool, loc~ : @syntax_types.Location)
  Match(cases~ : @list.T[MultiArgCase], has_error~ : @syntax_types.Location?, is_async~ : Bool, fn_loc~ : @syntax_types.Location, loc~ : @syntax_types.Location)
}
impl ToJson for Func

pub(all) enum FuncStubs {
  Import(module_name~ : String, func_name~ : String)
  Embedded(language~ : String?, code~ : EmbeddedCode)
}
impl ToJson for FuncStubs

pub(all) enum Group {
  Brace
  Paren
}
impl ToJson for Group

pub(all) enum Hole {
  Synthesized
  Incomplete
  Todo
}
impl ToJson for Hole

pub(all) enum Impl {
  TopExpr(expr~ : Expr, is_main~ : Bool, local_types~ : @list.T[LocalTypeDecl], loc~ : @syntax_types.Location)
  TopTest(expr~ : Expr, name~ : (String, @syntax_types.Location)?, params~ : @list.T[Parameter]?, local_types~ : @list.T[LocalTypeDecl], loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], mut doc~ : @syntax_types.DocString)
  TopTypeDef(TypeDecl)
  TopFuncDef(fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @syntax_types.Location)
  TopFuncAlias(pkg~ : Label?, type_name~ : TypeName?, targets~ : @list.T[AliasTarget], vis~ : Visibility, attrs~ : @list.T[@syntax_types.Attribute], is_list~ : Bool, mut doc~ : @syntax_types.DocString, loc~ : @syntax_types.Location)
  TopLetDef(binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], mut doc~ : @syntax_types.DocString)
  TopTrait(TraitDecl)
  TopBatchTypeAlias(pkg~ : Label?, targets~ : @list.T[AliasTarget], vis~ : Visibility, loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], is_list~ : Bool, mut doc~ : @syntax_types.DocString)
  TopBatchTraitAlias(pkg~ : Label?, targets~ : @list.T[AliasTarget], vis~ : Visibility, loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], is_list~ : Bool, mut doc~ : @syntax_types.DocString)
  TopImpl(self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @syntax_types.Location?, quantifiers~ : @list.T[TypeVarBinder], params~ : @list.T[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], mut doc~ : @syntax_types.DocString)
  TopView(quantifiers~ : @list.T[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @syntax_types.Location, view_constrs~ : @list.T[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.T[Parameter], params_loc~ : @syntax_types.Location, body~ : Expr, vis~ : Visibility, loc~ : @syntax_types.Location, attrs~ : @list.T[@syntax_types.Attribute], mut doc~ : @syntax_types.DocString)
  TopImplRelation(self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.T[TypeVarBinder], vis~ : Visibility, attrs~ : @list.T[@syntax_types.Attribute], loc~ : @syntax_types.Location, mut doc~ : @syntax_types.DocString)
}
impl ToJson for Impl

pub(all) enum InterpElem {
  Literal(repr~ : String, loc~ : @syntax_types.Location)
  Expr(expr~ : Expr, loc~ : @syntax_types.Location)
  Source(@syntax_types.InterpSource)
}
impl ToJson for InterpElem

pub(all) enum InterpolationComponent {
  InterpLit(String, @syntax_types.Location)
  InterpSource(@syntax_types.InterpSource)
}

pub(all) struct Label {
  name : String
  loc : @syntax_types.Location
}
impl ToJson for Label

pub(all) struct LocalTypeDecl {
  tycon : String
  tycon_loc : @syntax_types.Location
  components : TypeDesc
  deriving : @list.T[DerivingDirective]
}
impl ToJson for LocalTypeDecl

pub(all) enum LongIdent {
  Ident(name~ : String)
  Dot(pkg~ : String, id~ : String)
}
impl ToJson for LongIdent

pub(all) struct MapExprElem {
  key : Constant
  expr : Expr
  key_loc : @syntax_types.Location
  loc : @syntax_types.Location
}
impl ToJson for MapExprElem

pub(all) struct MapPatElem {
  key : Constant
  pat : Pattern
  match_absent : Bool
  key_loc : @syntax_types.Location
  loc : @syntax_types.Location
}
impl ToJson for MapPatElem

pub(all) struct MultiArgCase {
  patterns : @list.T[Pattern]
  guard_ : Expr?
  body : Expr
}
impl ToJson for MultiArgCase

pub(all) enum MultilineStringElem {
  String(String)
  Interp(@list.T[InterpElem])
}
impl ToJson for MultilineStringElem

pub(all) enum Parameter {
  DiscardPositional(ty~ : Type?, loc~ : @syntax_types.Location)
  Positional(binder~ : Binder, ty~ : Type?)
  Labelled(binder~ : Binder, ty~ : Type?)
  Optional(binder~ : Binder, default~ : Expr, ty~ : Type?)
  QuestionOptional(binder~ : Binder, ty~ : Type?)
}
impl ToJson for Parameter

pub(all) enum Pattern {
  Alias(pat~ : Pattern, alias_~ : Binder, loc~ : @syntax_types.Location)
  Any(loc~ : @syntax_types.Location)
  Array(pats~ : ArrayPatterns, loc~ : @syntax_types.Location)
  Constant(c~ : Constant, loc~ : @syntax_types.Location)
  Constraint(pat~ : Pattern, ty~ : Type, loc~ : @syntax_types.Location)
  Constr(constr~ : Constructor, args~ : @list.T[ConstrPatArg]?, is_open~ : Bool, loc~ : @syntax_types.Location)
  Or(pat1~ : Pattern, pat2~ : Pattern, loc~ : @syntax_types.Location)
  Tuple(pats~ : @list.T[Pattern], loc~ : @syntax_types.Location)
  Var(Binder)
  Record(fields~ : @list.T[FieldPat], is_closed~ : Bool, loc~ : @syntax_types.Location)
  Map(elems~ : @list.T[MapPatElem], is_closed~ : Bool, loc~ : @syntax_types.Location)
  Range(lhs~ : Pattern, rhs~ : Pattern, inclusive~ : Bool, loc~ : @syntax_types.Location)
}
impl ToJson for Pattern

pub(all) enum SemiExprProp {
  StmtExpr(Expr)
  StmtLet(pat~ : Pattern, expr~ : Expr, loc~ : @syntax_types.Location)
  StmtGuard(cond~ : Expr, otherwise~ : Expr?, loc~ : @syntax_types.Location)
  StmtLetmut(binder~ : Binder, ty_opt~ : Type?, expr~ : Expr, loc~ : @syntax_types.Location)
  StmtFunc(binder~ : Binder, func~ : Func, loc~ : @syntax_types.Location)
  StmtLetand(bindings~ : @list.T[(Binder, Type?, Func)], loc~ : @syntax_types.Location)
  StmtDefer(expr~ : Expr, loc~ : @syntax_types.Location)
}
fn SemiExprProp::collect_letrec(loc~ : @syntax_types.Location, @list.T[(Binder, Func)], @list.T[Self], Expr) -> Expr
fn SemiExprProp::collect_rev(@list.T[Self], Expr) -> Expr
fn SemiExprProp::collect_sequence(loc~ : @syntax_types.Location, @list.T[Expr], @list.T[Self], Expr) -> Expr
fn SemiExprProp::compact_rev(@list.T[Self], loc~ : @syntax_types.Location) -> Expr

pub(all) enum SpreadableElem {
  Regular(Expr)
  Spread(expr~ : Expr, loc~ : @syntax_types.Location)
}
impl ToJson for SpreadableElem

pub(all) struct StaticAssertion {
  ty : Type
  trait_ : LongIdent
  loc : @syntax_types.Location
  msg : String
}
impl ToJson for StaticAssertion

pub(all) enum TrailingMark {
  Comma
  Semi
  None
}
impl ToJson for TrailingMark

pub(all) struct TraitDecl {
  name : Binder
  supers : @list.T[TypeVarConstraint]
  methods : @list.T[TraitMethodDecl]
  vis : Visibility
  loc : @syntax_types.Location
  attrs : @list.T[@syntax_types.Attribute]
  mut doc : @syntax_types.DocString
}
impl ToJson for TraitDecl

pub(all) struct TraitMethodDecl {
  name : Binder
  has_error : @syntax_types.Location?
  is_async : Bool
  quantifiers : @list.T[TypeVarBinder]
  params : @list.T[Parameter]
  return_type : Type?
  error_type : ErrorType
  has_default : @syntax_types.Location?
  loc : @syntax_types.Location
}
impl ToJson for TraitMethodDecl

pub(all) enum TryOperatorKind {
  Question
  Exclamation
}
impl ToJson for TryOperatorKind

pub(all) enum Type {
  Any(loc~ : @syntax_types.Location)
  Arrow(args~ : @list.T[Type], res~ : Type, err~ : ErrorType, is_async~ : Bool, loc~ : @syntax_types.Location)
  Tuple(tys~ : @list.T[Type], loc~ : @syntax_types.Location)
  Name(constr_id~ : ConstrId, tys~ : @list.T[Type], loc~ : @syntax_types.Location)
  Option(ty~ : Type, loc~ : @syntax_types.Location, question_loc~ : @syntax_types.Location)
  Object(ConstrId)
}
impl ToJson for Type

pub(all) struct TypeDecl {
  tycon : String
  tycon_loc : @syntax_types.Location
  params : @list.T[TypeDeclBinder]
  components : TypeDesc
  attrs : @list.T[@syntax_types.Attribute]
  mut doc : @syntax_types.DocString
  type_vis : Visibility
  deriving : @list.T[DerivingDirective]
  loc : @syntax_types.Location
}
impl ToJson for TypeDecl

pub(all) struct TypeDeclBinder {
  name : String?
  loc : @syntax_types.Location
}
impl ToJson for TypeDeclBinder

pub(all) enum TypeDesc {
  Abstract
  Extern
  Newtype(Type)
  Error(ExceptionDecl)
  Variant(@list.T[ConstrDecl])
  Record(@list.T[FieldDecl])
  Alias(Type)
}
impl ToJson for TypeDesc

pub(all) struct TypeName {
  name : LongIdent
  is_object : Bool
  loc : @syntax_types.Location
}
impl ToJson for TypeName

pub(all) struct TypeVarBinder {
  name : String
  constraints : @list.T[TypeVarConstraint]
  loc : @syntax_types.Location
}
impl ToJson for TypeVarBinder

pub(all) struct TypeVarConstraint {
  trait_ : LongIdent
  loc : @syntax_types.Location
}
impl ToJson for TypeVarConstraint

pub(all) struct Var {
  name : LongIdent
  loc : @syntax_types.Location
}
impl ToJson for Var

pub(all) enum Visibility {
  Default
  Pub(attr~ : String?, loc~ : @syntax_types.Location)
  Priv(loc~ : @syntax_types.Location)
}
impl ToJson for Visibility

// Type aliases
pub typealias @syntax_types.Attribute as Attribute

pub typealias String as ByteLiteral

pub typealias String as BytesLiteral

pub typealias String as CharLiteral

pub typealias @syntax_types.DocString as DocString

pub typealias @list.T[Impl] as Impls

pub typealias @syntax_types.InterpSource as InterpSource

pub typealias @syntax_types.Location as Location

pub typealias @list.T[Parameter] as Parameters

pub typealias @syntax_types.Position as Position

pub typealias String as StringLiteral

pub typealias (String, @syntax_types.Location)? as TestName

// Traits

