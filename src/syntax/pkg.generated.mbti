// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/parser/syntax"

import(
  "moonbitlang/core/list"
  "moonbitlang/parser/basic"
  "moonbitlang/parser/tokens"
)

// Values
fn arrow_fn_param_to_expr(ArrowFnParam) -> Expr

fn binder_to_expr(Binder) -> Expr

fn bracket_loc(Expr) -> @basic.Location

fn desugar_array_augmented_set(@basic.Location, Var, Expr, Expr, Expr) -> Expr

fn desugar_array_get(loc~ : @basic.Location, Expr, Expr) -> Expr

fn desugar_array_set(loc~ : @basic.Location, Expr, Expr, Expr) -> Expr

fn impls_to_json(@list.List[Impl]) -> Json

fn label_to_expr(loc~ : @basic.Location, Label) -> Expr

fn label_to_pat(loc~ : @basic.Location, Label) -> Pattern

fn loc_of_expression(Expr) -> @basic.Location

fn make_alias_pattern(loc~ : @basic.Location, Pattern, Binder) -> Pattern

fn make_array_expr(loc~ : @basic.Location, @list.List[SpreadableElem]) -> Expr

fn make_arrow_fn(@list.List[(ArrowFnParam, Type?)], Expr, loc~ : @basic.Location) -> Func

fn make_assign_opt(loc~ : @basic.Location, Expr, Expr) -> Expr?

fn make_attribute(loc~ : @basic.Location, id~ : String, dot_id~ : String?, raw_payload~ : String) -> Attribute

fn make_augmented_assign_opt(loc~ : @basic.Location, Var, Expr, Expr) -> Expr?

fn make_constant_expr(loc~ : @basic.Location, Constant) -> Expr

fn make_constant_pattern(loc~ : @basic.Location, Constant) -> Pattern

fn make_constr_pattern(loc~ : @basic.Location, Constructor, @list.List[ConstrPatArg]?, Bool) -> Pattern

fn make_double(String) -> Constant

fn make_field_def(loc~ : @basic.Location, Label, Expr, Bool) -> FieldDef

fn make_field_pat(loc~ : @basic.Location, Label, Pattern, Bool) -> FieldPat

fn make_float(String) -> Constant

fn make_ident_expr(loc~ : @basic.Location, Var) -> Expr

fn make_int(String) -> Constant

fn make_interp_expr(loc~ : @basic.Location, Array[@tokens.InterpElem]) -> Expr

fn make_interps(Array[@tokens.InterpElem]) -> @list.List[InterpElem]

fn make_option_type(loc~ : @basic.Location, constr_loc~ : @basic.Location, Type) -> Type

fn make_record_expr(loc~ : @basic.Location, trailing~ : TrailingMark, TypeName?, @list.List[FieldDef]) -> Expr

fn make_tuple_expr(loc~ : @basic.Location, @list.List[Expr]) -> Expr

fn make_tuple_pattern(loc~ : @basic.Location, @list.List[Pattern]) -> Pattern

fn make_tuple_type(loc~ : @basic.Location, @list.List[Type]) -> Type

fn make_uminus(loc~ : @basic.Location, String, Expr) -> Expr

fn make_unot(loc~ : @basic.Location, Expr) -> Expr

fn make_uplus(loc~ : @basic.Location, String, Expr) -> Expr

let no_location : @basic.Location

// Errors

// Types and methods
pub(all) enum Accessor {
  Label(Label)
  Index(tuple_index~ : Int, loc~ : @basic.Location)
  Newtype(loc~ : @basic.Location)
}
impl ToJson for Accessor

pub(all) struct AliasTarget {
  binder : Binder
  target : Label?
}
impl ToJson for AliasTarget

pub(all) enum ApplyAttr {
  NoAttr
  Exclamation
  Question
}
impl ToJson for ApplyAttr

pub(all) struct Argument {
  value : Expr
  kind : ArgumentKind
}
impl ToJson for Argument

pub(all) enum ArgumentKind {
  Positional
  Labelled(Label)
  LabelledPun(Label)
  LabelledOption(label~ : Label, question_loc~ : @basic.Location)
  LabelledOptionPun(label~ : Label, question_loc~ : @basic.Location)
}
impl ToJson for ArgumentKind

pub(all) enum ArrayPattern {
  Pattern(Pattern)
  StringSpread(String)
  BytesSpread(String)
  ConstSpread(binder~ : Binder, pkg~ : String?, loc~ : @basic.Location)
}
impl ToJson for ArrayPattern

pub(all) enum ArrayPatterns {
  Closed(@list.List[ArrayPattern])
  Open(@list.List[ArrayPattern], @list.List[ArrayPattern], DotDotBinder)
}
impl ToJson for ArrayPatterns

pub(all) enum ArrowFnParam {
  Named(Binder)
  Unnamed(@basic.Location)
}

pub(all) struct Attribute {
  loc : @basic.Location
  raw : String
  parsed : AttributeExpr?
}
impl ToJson for Attribute

pub(all) enum AttributeExpr {
  Ident(AttributeId)
  Str(String)
  Apply(AttributeId, @list.List[AttributeProp])
}

pub(all) struct AttributeId {
  qual : String?
  name : String
}

pub(all) enum AttributeProp {
  Labeled(String, AttributeExpr)
  Expr(AttributeExpr)
}

pub(all) struct Binder {
  name : String
  loc : @basic.Location
}
impl ToJson for Binder

pub(all) struct Case {
  pattern : Pattern
  guard_ : Expr?
  body : Expr
}
impl ToJson for Case

pub(all) enum Constant {
  Bool(Bool)
  Byte(String)
  Bytes(String)
  Char(String)
  Int(String)
  Int64(String)
  UInt(String)
  UInt64(String)
  Float(String)
  Double(String)
  String(String)
  BigInt(String)
}
impl ToJson for Constant

pub(all) struct ConstrDecl {
  name : ConstrName
  args : @list.List[ConstrParam]?
  tag : (String, @basic.Location)?
  loc : @basic.Location
  attrs : @list.List[Attribute]
  mut doc : DocString
}
impl ToJson for ConstrDecl

pub(all) struct ConstrId {
  id : LongIdent
  loc : @basic.Location
}
impl ToJson for ConstrId

pub(all) struct ConstrName {
  name : String
  loc : @basic.Location
}
impl ToJson for ConstrName

pub(all) struct ConstrParam {
  ty : Type
  mut_ : Bool
  label : Label?
}
impl ToJson for ConstrParam

pub(all) struct ConstrPatArg {
  pat : Pattern
  kind : ArgumentKind
}
impl ToJson for ConstrPatArg

pub(all) struct Constructor {
  name : ConstrName
  extra_info : ConstructorExtraInfo
  loc : @basic.Location
}
impl ToJson for Constructor

pub(all) enum ConstructorExtraInfo {
  TypeName(TypeName)
  Package(String)
  NoExtraInfo
}
impl ToJson for ConstructorExtraInfo

pub(all) enum DeclBody {
  DeclBody(local_types~ : @list.List[LocalTypeDecl], expr~ : Expr)
  DeclStubs(FuncStubs)
}
impl ToJson for DeclBody

pub(all) struct DerivingDirective {
  type_name : TypeName
  args : @list.List[Argument]
  loc : @basic.Location
}
impl ToJson for DerivingDirective

pub(all) struct DocString {
  content : @list.List[String]
  loc : @basic.Location
}
fn DocString::empty() -> Self
impl ToJson for DocString

pub(all) enum DotDotBinder {
  Underscore
  NoBinder
  BinderAs(Binder)
  Binder(Binder)
}
impl ToJson for DotDotBinder

pub(all) enum EmbeddedCode {
  CodeString(String)
  CodeMultilineString(@list.List[String])
}
impl ToJson for EmbeddedCode

pub(all) enum ErrorType {
  ErrorType(ty~ : Type)
  DefaultErrorType(loc~ : @basic.Location)
  NoErrorType
  Noraise(loc~ : @basic.Location)
  MaybeError(ty~ : Type)
}
impl ToJson for ErrorType

pub(all) enum ExceptionDecl {
  NoPayload
  SinglePayload(Type)
  EnumPayload(@list.List[ConstrDecl])
}
impl ToJson for ExceptionDecl

pub(all) enum Expr {
  Apply(func~ : Expr, args~ : @list.List[Argument], attr~ : ApplyAttr, loc~ : @basic.Location)
  Infix(op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location)
  Unary(op~ : Var, expr~ : Expr, loc~ : @basic.Location)
  Array(exprs~ : @list.List[Expr], loc~ : @basic.Location)
  ArraySpread(elems~ : @list.List[SpreadableElem], loc~ : @basic.Location)
  ArrayGet(array~ : Expr, index~ : Expr, loc~ : @basic.Location)
  ArrayGetSlice(array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @basic.Location, loc~ : @basic.Location)
  ArraySet(array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location)
  ArrayAugmentedSet(op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location)
  Constant(c~ : Constant, loc~ : @basic.Location)
  MultilineString(elems~ : @list.List[MultilineStringElem], loc~ : @basic.Location)
  Interp(elems~ : @list.List[InterpElem], loc~ : @basic.Location)
  Constraint(expr~ : Expr, ty~ : Type, loc~ : @basic.Location)
  Constr(constr~ : Constructor, loc~ : @basic.Location)
  While(loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Function(func~ : Func, loc~ : @basic.Location)
  Ident(id~ : Var, loc~ : @basic.Location)
  If(cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @basic.Location)
  Guard(cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @basic.Location)
  Is(expr~ : Expr, pat~ : Pattern, loc~ : @basic.Location)
  Defer(expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  LetFn(name~ : Binder, func~ : Func, body~ : Expr, loc~ : @basic.Location)
  LetRec(bindings~ : @list.List[(Binder, Func)], body~ : Expr, loc~ : @basic.Location)
  LetAnd(bindings~ : @list.List[(Binder, Type?, Func)], body~ : Expr, loc~ : @basic.Location)
  Let(pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  Sequence(exprs~ : @list.List[Expr], last_expr~ : Expr, loc~ : @basic.Location)
  Tuple(exprs~ : @list.List[Expr], loc~ : @basic.Location)
  Record(type_name~ : TypeName?, fields~ : @list.List[FieldDef], trailing~ : TrailingMark, loc~ : @basic.Location)
  RecordUpdate(type_name~ : TypeName?, record~ : Expr, fields~ : @list.List[FieldDef], loc~ : @basic.Location)
  Field(record~ : Expr, accessor~ : Accessor, loc~ : @basic.Location)
  Method(type_name~ : TypeName, method_name~ : Label, loc~ : @basic.Location)
  DotApply(self~ : Expr, method_name~ : Label, args~ : @list.List[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @basic.Location)
  As(expr~ : Expr, trait_~ : TypeName, loc~ : @basic.Location)
  Mutate(record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location)
  Match(expr~ : Expr, cases~ : @list.List[Case], match_loc~ : @basic.Location, using_~ : Label?, loc~ : @basic.Location)
  LetMut(binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  Pipe(lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location)
  Assign(var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location)
  Hole(loc~ : @basic.Location, kind~ : Hole)
  Return(return_value~ : Expr?, loc~ : @basic.Location)
  Raise(err_value~ : Expr, loc~ : @basic.Location)
  Unit(loc~ : @basic.Location, faked~ : Bool)
  Break(arg~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Continue(args~ : @list.List[Expr], label~ : Label?, loc~ : @basic.Location)
  Loop(args~ : @list.List[Expr], body~ : @list.List[MultiArgCase], label~ : Label?, loop_loc~ : @basic.Location, loc~ : @basic.Location)
  For(binders~ : @list.List[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.List[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  ForEach(binders~ : @list.List[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Try(body~ : Expr, catch_~ : @list.List[Case], catch_all~ : Bool, try_else~ : @list.List[Case]?, has_try~ : Bool, try_loc~ : @basic.Location, catch_loc~ : @basic.Location, else_loc~ : @basic.Location, loc~ : @basic.Location)
  TryOperator(body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @basic.Location, loc~ : @basic.Location)
  Map(elems~ : @list.List[MapExprElem], loc~ : @basic.Location)
  Group(expr~ : Expr, group~ : Group, loc~ : @basic.Location)
  StaticAssert(asserts~ : @list.List[StaticAssertion], body~ : Expr)
}
fn Expr::loc(Self) -> @basic.Location
impl ToJson for Expr

pub(all) struct FieldDecl {
  name : FieldName
  ty : Type
  mut_ : Bool
  vis : Visibility
  loc : @basic.Location
  attrs : @list.List[Attribute]
  mut doc : DocString
}
impl ToJson for FieldDecl

pub(all) struct FieldDef {
  label : Label
  expr : Expr
  is_pun : Bool
  loc : @basic.Location
}
impl ToJson for FieldDef

pub(all) struct FieldName {
  label : String
  loc : @basic.Location
}
impl ToJson for FieldName

pub(all) struct FieldPat {
  label : Label
  pattern : Pattern
  is_pun : Bool
  loc : @basic.Location
}
impl ToJson for FieldPat

pub(all) enum FnKind {
  Lambda
  Matrix
  Arrow
}
impl ToJson for FnKind

pub(all) struct FunDecl {
  type_name : TypeName?
  name : Binder
  has_error : @basic.Location?
  is_async : Bool
  decl_params : @list.List[Parameter]?
  params_loc : @basic.Location
  quantifiers : @list.List[TypeVarBinder]
  return_type : Type?
  error_type : ErrorType
  vis : Visibility
  attrs : @list.List[Attribute]
  mut doc : DocString
}
impl ToJson for FunDecl

pub(all) enum Func {
  Lambda(parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, return_type~ : Type?, error_type~ : ErrorType, kind~ : FnKind, has_error~ : @basic.Location?, is_async~ : Bool, loc~ : @basic.Location)
  Match(cases~ : @list.List[MultiArgCase], has_error~ : @basic.Location?, is_async~ : Bool, fn_loc~ : @basic.Location, loc~ : @basic.Location)
}
impl ToJson for Func

pub(all) enum FuncStubs {
  Import(module_name~ : String, func_name~ : String)
  Embedded(language~ : String?, code~ : EmbeddedCode)
}
impl ToJson for FuncStubs

pub(all) enum Group {
  Brace
  Paren
}
impl ToJson for Group

pub(all) enum Hole {
  Synthesized
  Incomplete
  Todo
}
impl ToJson for Hole

pub(all) enum Impl {
  TopExpr(expr~ : Expr, is_main~ : Bool, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location)
  TopTest(expr~ : Expr, name~ : (String, @basic.Location)?, params~ : @list.List[Parameter]?, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location, attrs~ : @list.List[Attribute], mut doc~ : DocString)
  TopTypeDef(TypeDecl)
  TopFuncDef(fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @basic.Location)
  TopFuncAlias(pkg~ : Label?, type_name~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, attrs~ : @list.List[Attribute], is_list~ : Bool, mut doc~ : DocString, loc~ : @basic.Location)
  TopLetDef(binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @basic.Location, attrs~ : @list.List[Attribute], mut doc~ : DocString)
  TopTrait(TraitDecl)
  TopBatchTypeAlias(pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], is_list~ : Bool, mut doc~ : DocString)
  TopBatchTraitAlias(pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], is_list~ : Bool, mut doc~ : DocString)
  TopImpl(self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @basic.Location?, quantifiers~ : @list.List[TypeVarBinder], params~ : @list.List[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], mut doc~ : DocString)
  TopView(quantifiers~ : @list.List[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @basic.Location, view_constrs~ : @list.List[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], mut doc~ : DocString)
  TopImplRelation(self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.List[TypeVarBinder], vis~ : Visibility, attrs~ : @list.List[Attribute], loc~ : @basic.Location, mut doc~ : DocString)
}
fn Impl::loc(Self) -> @basic.Location
impl ToJson for Impl

pub(all) enum InterpElem {
  Literal(repr~ : String, loc~ : @basic.Location)
  Expr(expr~ : Expr, loc~ : @basic.Location)
  Source(@tokens.InterpSource)
}
impl ToJson for InterpElem

pub(all) enum InterpolationComponent {
  InterpLit(String, @basic.Location)
  InterpSource(@tokens.InterpSource)
}

pub(all) struct Label {
  name : String
  loc : @basic.Location
}
impl ToJson for Label

pub(all) struct LocalTypeDecl {
  tycon : String
  tycon_loc : @basic.Location
  components : TypeDesc
  deriving : @list.List[DerivingDirective]
}
impl ToJson for LocalTypeDecl

pub(all) enum LongIdent {
  Ident(name~ : String)
  Dot(pkg~ : String, id~ : String)
}
fn LongIdent::dummy() -> Self
impl ToJson for LongIdent

pub(all) struct MapExprElem {
  key : Constant
  expr : Expr
  key_loc : @basic.Location
  loc : @basic.Location
}
impl ToJson for MapExprElem

pub(all) struct MapPatElem {
  key : Constant
  pat : Pattern
  match_absent : Bool
  key_loc : @basic.Location
  loc : @basic.Location
}
impl ToJson for MapPatElem

pub(all) struct MapVisitorBase[T](T)
fn[T] MapVisitorBase::inner(Self[T]) -> T
impl[T : ImplMapVisitor] ImplMapVisitor for MapVisitorBase[T]

pub(all) struct MultiArgCase {
  patterns : @list.List[Pattern]
  guard_ : Expr?
  body : Expr
}
impl ToJson for MultiArgCase

pub(all) enum MultilineStringElem {
  String(String)
  Interp(@list.List[InterpElem])
}
impl ToJson for MultilineStringElem

pub(all) enum Parameter {
  DiscardPositional(ty~ : Type?, loc~ : @basic.Location)
  Positional(binder~ : Binder, ty~ : Type?)
  Labelled(binder~ : Binder, ty~ : Type?)
  Optional(binder~ : Binder, default~ : Expr, ty~ : Type?)
  QuestionOptional(binder~ : Binder, ty~ : Type?)
}
impl ToJson for Parameter

pub(all) enum Pattern {
  Alias(pat~ : Pattern, alias_~ : Binder, loc~ : @basic.Location)
  Any(loc~ : @basic.Location)
  Array(pats~ : ArrayPatterns, loc~ : @basic.Location)
  Constant(c~ : Constant, loc~ : @basic.Location)
  Constraint(pat~ : Pattern, ty~ : Type, loc~ : @basic.Location)
  Constr(constr~ : Constructor, args~ : @list.List[ConstrPatArg]?, is_open~ : Bool, loc~ : @basic.Location)
  Or(pat1~ : Pattern, pat2~ : Pattern, loc~ : @basic.Location)
  Tuple(pats~ : @list.List[Pattern], loc~ : @basic.Location)
  Var(Binder)
  Record(fields~ : @list.List[FieldPat], is_closed~ : Bool, loc~ : @basic.Location)
  Map(elems~ : @list.List[MapPatElem], is_closed~ : Bool, loc~ : @basic.Location)
  Range(lhs~ : Pattern, rhs~ : Pattern, inclusive~ : Bool, loc~ : @basic.Location)
}
fn Pattern::loc(Self) -> @basic.Location
impl ToJson for Pattern

pub(all) enum SpreadableElem {
  Regular(Expr)
  Spread(expr~ : Expr, loc~ : @basic.Location)
}
impl ToJson for SpreadableElem

pub(all) struct StaticAssertion {
  ty : Type
  trait_ : LongIdent
  loc : @basic.Location
  msg : String
}
impl ToJson for StaticAssertion

pub(all) enum TrailingMark {
  Comma
  Semi
  None
}
impl ToJson for TrailingMark

pub(all) struct TraitDecl {
  name : Binder
  supers : @list.List[TypeVarConstraint]
  methods : @list.List[TraitMethodDecl]
  vis : Visibility
  loc : @basic.Location
  attrs : @list.List[Attribute]
  mut doc : DocString
}
impl ToJson for TraitDecl

pub(all) struct TraitMethodDecl {
  name : Binder
  has_error : @basic.Location?
  is_async : Bool
  quantifiers : @list.List[TypeVarBinder]
  params : @list.List[Parameter]
  return_type : Type?
  error_type : ErrorType
  has_default : @basic.Location?
  attrs : @list.List[Attribute]
  loc : @basic.Location
}
impl ToJson for TraitMethodDecl

pub(all) enum TryOperatorKind {
  Question
  Exclamation
}
impl ToJson for TryOperatorKind

pub(all) enum Type {
  Any(loc~ : @basic.Location)
  Arrow(args~ : @list.List[Type], res~ : Type, err~ : ErrorType, is_async~ : Bool, loc~ : @basic.Location)
  Tuple(tys~ : @list.List[Type], loc~ : @basic.Location)
  Name(constr_id~ : ConstrId, tys~ : @list.List[Type], loc~ : @basic.Location)
  Option(ty~ : Type, loc~ : @basic.Location, question_loc~ : @basic.Location)
  Object(ConstrId)
}
fn Type::loc(Self) -> @basic.Location
impl ToJson for Type

pub(all) struct TypeDecl {
  tycon : String
  tycon_loc : @basic.Location
  params : @list.List[TypeDeclBinder]
  components : TypeDesc
  attrs : @list.List[Attribute]
  mut doc : DocString
  type_vis : Visibility
  deriving : @list.List[DerivingDirective]
  loc : @basic.Location
}
impl ToJson for TypeDecl

pub(all) struct TypeDeclBinder {
  name : String?
  loc : @basic.Location
}
impl ToJson for TypeDeclBinder

pub(all) enum TypeDesc {
  Abstract
  Extern
  Newtype(Type)
  Error(ExceptionDecl)
  Variant(@list.List[ConstrDecl])
  Record(@list.List[FieldDecl])
  TupleStruct(@list.List[Type])
  Alias(Type)
}
impl ToJson for TypeDesc

pub(all) struct TypeName {
  name : LongIdent
  is_object : Bool
  loc : @basic.Location
}
impl ToJson for TypeName

pub(all) struct TypeVarBinder {
  name : String
  constraints : @list.List[TypeVarConstraint]
  loc : @basic.Location
}
impl ToJson for TypeVarBinder

pub(all) struct TypeVarConstraint {
  trait_ : LongIdent
  loc : @basic.Location
}
impl ToJson for TypeVarConstraint

pub(all) struct Var {
  name : LongIdent
  loc : @basic.Location
}
impl ToJson for Var

pub(all) enum Visibility {
  Default
  Pub(attr~ : String?, loc~ : @basic.Location)
  Priv(loc~ : @basic.Location)
}
impl ToJson for Visibility

// Type aliases
pub typealias @list.List[Impl] as Impls

pub typealias @list.List[Parameter] as Parameters

pub typealias (String, @basic.Location)? as TestName

// Traits
pub(open) trait ImplMapVisitor {
  base(Self) -> MapVisitorBase[Self] = _
  visit_impl(Self, Impl) -> Impl = _
  visit_top_expr(Self, expr~ : Expr, is_main~ : Bool, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location) -> Impl = _
  visit_top_test(Self, expr~ : Expr, name~ : (String, @basic.Location)?, params~ : @list.List[Parameter]?, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location, attrs~ : @list.List[Attribute], doc~ : DocString) -> Impl = _
  visit_top_type_def(Self, TypeDecl) -> Impl = _
  visit_top_func_def(Self, fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @basic.Location) -> Impl = _
  visit_top_func_alias(Self, pkg~ : Label?, type_name~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, attrs~ : @list.List[Attribute], is_list~ : Bool, doc~ : DocString, loc~ : @basic.Location) -> Impl = _
  visit_top_let_def(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @basic.Location, attrs~ : @list.List[Attribute], doc~ : DocString) -> Impl = _
  visit_top_trait(Self, TraitDecl) -> Impl = _
  visit_top_batch_type_alias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], is_list~ : Bool, doc~ : DocString) -> Impl = _
  visit_top_batch_trait_alias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], is_list~ : Bool, doc~ : DocString) -> Impl = _
  visit_top_impl(Self, self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @basic.Location?, quantifiers~ : @list.List[TypeVarBinder], params~ : @list.List[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], doc~ : DocString) -> Impl = _
  visit_top_view(Self, quantifiers~ : @list.List[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @basic.Location, view_constrs~ : @list.List[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[Attribute], doc~ : DocString) -> Impl = _
  visit_top_impl_relation(Self, self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.List[TypeVarBinder], vis~ : Visibility, attrs~ : @list.List[Attribute], loc~ : @basic.Location, doc~ : DocString) -> Impl = _
  visit_expr(Self, Expr) -> Expr = _
  visit_apply(Self, func~ : Expr, args~ : @list.List[Argument], attr~ : ApplyAttr, loc~ : @basic.Location) -> Expr = _
  visit_infix(Self, op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_unary(Self, op~ : Var, expr~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_array(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Expr = _
  visit_array_spread(Self, elems~ : @list.List[SpreadableElem], loc~ : @basic.Location) -> Expr = _
  visit_array_get(Self, array~ : Expr, index~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_array_get_slice(Self, array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_array_set(Self, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_array_augmented_set(Self, op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_constant(Self, c~ : Constant, loc~ : @basic.Location) -> Expr = _
  visit_multiline_string(Self, elems~ : @list.List[MultilineStringElem], loc~ : @basic.Location) -> Expr = _
  visit_interp(Self, elems~ : @list.List[InterpElem], loc~ : @basic.Location) -> Expr = _
  visit_constraint(Self, expr~ : Expr, ty~ : Type, loc~ : @basic.Location) -> Expr = _
  visit_constr(Self, constr~ : Constructor, loc~ : @basic.Location) -> Expr = _
  visit_while(Self, loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_function(Self, func~ : Func, loc~ : @basic.Location) -> Expr = _
  visit_ident(Self, id~ : Var, loc~ : @basic.Location) -> Expr = _
  visit_if(Self, cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @basic.Location) -> Expr = _
  visit_guard(Self, cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_is(Self, expr~ : Expr, pat~ : Pattern, loc~ : @basic.Location) -> Expr = _
  visit_defer(Self, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_let_fn(Self, name~ : Binder, func~ : Func, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_let_rec(Self, bindings~ : @list.List[(Binder, Func)], body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_let_and(Self, bindings~ : @list.List[(Binder, Type?, Func)], body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_let(Self, pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_sequence(Self, exprs~ : @list.List[Expr], last_expr~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_tuple(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Expr = _
  visit_record(Self, type_name~ : TypeName?, fields~ : @list.List[FieldDef], trailing~ : TrailingMark, loc~ : @basic.Location) -> Expr = _
  visit_record_update(Self, type_name~ : TypeName?, record~ : Expr, fields~ : @list.List[FieldDef], loc~ : @basic.Location) -> Expr = _
  visit_field(Self, record~ : Expr, accessor~ : Accessor, loc~ : @basic.Location) -> Expr = _
  visit_method(Self, type_name~ : TypeName, method_name~ : Label, loc~ : @basic.Location) -> Expr = _
  visit_dot_apply(Self, self~ : Expr, method_name~ : Label, args~ : @list.List[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @basic.Location) -> Expr = _
  visit_as(Self, expr~ : Expr, trait_~ : TypeName, loc~ : @basic.Location) -> Expr = _
  visit_mutate(Self, record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Expr = _
  visit_match(Self, expr~ : Expr, cases~ : @list.List[Case], match_loc~ : @basic.Location, using_~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_let_mut(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_pipe(Self, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_assign(Self, var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Expr = _
  visit_hole(Self, loc~ : @basic.Location, kind~ : Hole) -> Expr = _
  visit_return(Self, return_value~ : Expr?, loc~ : @basic.Location) -> Expr = _
  visit_raise(Self, err_value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_unit(Self, loc~ : @basic.Location, faked~ : Bool) -> Expr = _
  visit_break(Self, arg~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_continue(Self, args~ : @list.List[Expr], label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_loop(Self, args~ : @list.List[Expr], body~ : @list.List[MultiArgCase], label~ : Label?, loop_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_for(Self, binders~ : @list.List[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.List[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_for_each(Self, binders~ : @list.List[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_try(Self, body~ : Expr, catch_~ : @list.List[Case], catch_all~ : Bool, try_else~ : @list.List[Case]?, has_try~ : Bool, try_loc~ : @basic.Location, catch_loc~ : @basic.Location, else_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_try_operator(Self, body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_map(Self, elems~ : @list.List[MapExprElem], loc~ : @basic.Location) -> Expr = _
  visit_group(Self, expr~ : Expr, group~ : Group, loc~ : @basic.Location) -> Expr = _
  visit_static_assert(Self, asserts~ : @list.List[StaticAssertion], body~ : Expr) -> Expr = _
}

