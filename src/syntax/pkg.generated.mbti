// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/parser/syntax"

import(
  "moonbitlang/core/list"
  "moonbitlang/parser/attribute"
  "moonbitlang/parser/basic"
  "moonbitlang/parser/tokens"
)

// Values
fn arrow_fn_param_to_expr(ArrowFnParam) -> Expr

fn binder_to_expr(Binder) -> Expr

fn bracket_loc(Expr) -> @basic.Location

fn desugar_array_augmented_set(@basic.Location, Var, Expr, Expr, Expr) -> Expr

fn desugar_array_get(loc~ : @basic.Location, Expr, Expr) -> Expr

fn desugar_array_set(loc~ : @basic.Location, Expr, Expr, Expr) -> Expr

fn impls_to_json(@list.List[Impl]) -> Json

fn label_to_expr(loc~ : @basic.Location, Label) -> Expr

fn label_to_pat(loc~ : @basic.Location, Label) -> Pattern

fn loc_of_expression(Expr) -> @basic.Location

fn make_alias_pattern(loc~ : @basic.Location, Pattern, Binder) -> Pattern

fn make_array_expr(loc~ : @basic.Location, @list.List[SpreadableElem]) -> Expr

fn make_arrow_fn(@list.List[(ArrowFnParam, Type?)], Expr, loc~ : @basic.Location) -> Func

fn make_assign_opt(loc~ : @basic.Location, Expr, Expr) -> Expr?

fn make_augmented_assign_opt(loc~ : @basic.Location, Var, Expr, Expr) -> Expr?

fn make_constant_expr(loc~ : @basic.Location, Constant) -> Expr

fn make_constant_pattern(loc~ : @basic.Location, Constant) -> Pattern

fn make_constr_pattern(loc~ : @basic.Location, Constructor, @list.List[ConstrPatArg]?, Bool) -> Pattern

fn make_double(String) -> Constant

fn make_field_def(loc~ : @basic.Location, Label, Expr, Bool) -> FieldDef

fn make_field_pat(loc~ : @basic.Location, Label, Pattern, Bool) -> FieldPat

fn make_float(String) -> Constant

fn make_ident_expr(loc~ : @basic.Location, Var) -> Expr

fn make_int(String) -> Constant

fn make_interp_expr(loc~ : @basic.Location, Array[@tokens.InterpElem]) -> Expr

fn make_interps(Array[@tokens.InterpElem]) -> @list.List[InterpElem]

fn make_option_type(loc~ : @basic.Location, constr_loc~ : @basic.Location, Type) -> Type

fn make_record_expr(loc~ : @basic.Location, trailing~ : TrailingMark, TypeName?, @list.List[FieldDef]) -> Expr

fn make_tuple_expr(loc~ : @basic.Location, @list.List[Expr]) -> Expr

fn make_tuple_pattern(loc~ : @basic.Location, @list.List[Pattern]) -> Pattern

fn make_tuple_type(loc~ : @basic.Location, @list.List[Type]) -> Type

fn make_uminus(loc~ : @basic.Location, String, Expr) -> Expr

fn make_unot(loc~ : @basic.Location, Expr) -> Expr

fn make_uplus(loc~ : @basic.Location, String, Expr) -> Expr

let no_location : @basic.Location

// Errors

// Types and methods
pub(all) enum Accessor {
  Label(Label)
  Index(tuple_index~ : Int, loc~ : @basic.Location)
  Newtype(loc~ : @basic.Location)
}
impl ToJson for Accessor

pub(all) struct AliasTarget {
  binder : Binder
  target : Label?
}
impl ToJson for AliasTarget

pub(all) enum ApplyAttr {
  NoAttr
  Exclamation
  Question
}
impl ToJson for ApplyAttr

pub(all) struct Argument {
  value : Expr
  kind : ArgumentKind
}
impl ToJson for Argument

pub(all) enum ArgumentKind {
  Positional
  Labelled(Label)
  LabelledPun(Label)
  LabelledOption(label~ : Label, question_loc~ : @basic.Location)
  LabelledOptionPun(label~ : Label, question_loc~ : @basic.Location)
}
impl ToJson for ArgumentKind

pub(all) enum ArrayPattern {
  Pattern(Pattern)
  StringSpread(String)
  BytesSpread(String)
  ConstSpread(binder~ : Binder, pkg~ : String?, loc~ : @basic.Location)
}
impl ToJson for ArrayPattern

pub(all) enum ArrayPatterns {
  Closed(@list.List[ArrayPattern])
  Open(@list.List[ArrayPattern], @list.List[ArrayPattern], DotDotBinder)
}
impl ToJson for ArrayPatterns

pub(all) enum ArrowFnParam {
  Named(Binder)
  Unnamed(@basic.Location)
}

pub(all) struct Binder {
  name : String
  loc : @basic.Location
}
impl ToJson for Binder

pub(all) struct Case {
  pattern : Pattern
  guard_ : Expr?
  body : Expr
}
impl ToJson for Case

pub(all) enum Constant {
  Bool(Bool)
  Byte(String)
  Bytes(String)
  Char(String)
  Int(String)
  Int64(String)
  UInt(String)
  UInt64(String)
  Float(String)
  Double(String)
  String(String)
  BigInt(String)
}
impl ToJson for Constant

pub(all) struct ConstrDecl {
  name : ConstrName
  args : @list.List[ConstrParam]?
  tag : (String, @basic.Location)?
  loc : @basic.Location
  attrs : @list.List[@attribute.Attribute]
  mut doc : DocString
}
impl ToJson for ConstrDecl

pub(all) struct ConstrId {
  id : LongIdent
  loc : @basic.Location
}
impl ToJson for ConstrId

pub(all) struct ConstrName {
  name : String
  loc : @basic.Location
}
impl ToJson for ConstrName

pub(all) struct ConstrParam {
  ty : Type
  mut_ : Bool
  label : Label?
}
impl ToJson for ConstrParam

pub(all) struct ConstrPatArg {
  pat : Pattern
  kind : ArgumentKind
}
impl ToJson for ConstrPatArg

pub(all) struct Constructor {
  name : ConstrName
  extra_info : ConstructorExtraInfo
  loc : @basic.Location
}
impl ToJson for Constructor

pub(all) enum ConstructorExtraInfo {
  TypeName(TypeName)
  Package(String)
  NoExtraInfo
}
impl ToJson for ConstructorExtraInfo

pub(all) enum DeclBody {
  DeclBody(local_types~ : @list.List[LocalTypeDecl], expr~ : Expr)
  DeclStubs(FuncStubs)
}
impl ToJson for DeclBody

pub(all) struct DerivingDirective {
  type_name : TypeName
  args : @list.List[Argument]
  loc : @basic.Location
}
impl ToJson for DerivingDirective

pub(all) struct DocString {
  content : @list.List[String]
  loc : @basic.Location
}
fn DocString::empty() -> Self
impl ToJson for DocString

pub(all) enum DotDotBinder {
  Underscore
  NoBinder
  BinderAs(Binder)
  Binder(Binder)
}
impl ToJson for DotDotBinder

pub(all) enum EmbeddedCode {
  CodeString(String)
  CodeMultilineString(@list.List[String])
}
impl ToJson for EmbeddedCode

pub(all) enum ErrorType {
  ErrorType(ty~ : Type)
  DefaultErrorType(loc~ : @basic.Location)
  NoErrorType
  Noraise(loc~ : @basic.Location)
  MaybeError(ty~ : Type)
}
impl ToJson for ErrorType

pub(all) enum ExceptionDecl {
  NoPayload
  SinglePayload(Type)
  EnumPayload(@list.List[ConstrDecl])
}
impl ToJson for ExceptionDecl

pub(all) enum Expr {
  Apply(func~ : Expr, args~ : @list.List[Argument], attr~ : ApplyAttr, loc~ : @basic.Location)
  Infix(op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location)
  Unary(op~ : Var, expr~ : Expr, loc~ : @basic.Location)
  Array(exprs~ : @list.List[Expr], loc~ : @basic.Location)
  ArraySpread(elems~ : @list.List[SpreadableElem], loc~ : @basic.Location)
  ArrayGet(array~ : Expr, index~ : Expr, loc~ : @basic.Location)
  ArrayGetSlice(array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @basic.Location, loc~ : @basic.Location)
  ArraySet(array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location)
  ArrayAugmentedSet(op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location)
  Constant(c~ : Constant, loc~ : @basic.Location)
  MultilineString(elems~ : @list.List[MultilineStringElem], loc~ : @basic.Location)
  Interp(elems~ : @list.List[InterpElem], loc~ : @basic.Location)
  Constraint(expr~ : Expr, ty~ : Type, loc~ : @basic.Location)
  Constr(constr~ : Constructor, loc~ : @basic.Location)
  While(loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Function(func~ : Func, loc~ : @basic.Location)
  Ident(id~ : Var, loc~ : @basic.Location)
  If(cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @basic.Location)
  Guard(cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @basic.Location)
  Is(expr~ : Expr, pat~ : Pattern, loc~ : @basic.Location)
  Defer(expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  LetFn(name~ : Binder, func~ : Func, body~ : Expr, loc~ : @basic.Location)
  LetRec(bindings~ : @list.List[(Binder, Func)], body~ : Expr, loc~ : @basic.Location)
  LetAnd(bindings~ : @list.List[(Binder, Type?, Func)], body~ : Expr, loc~ : @basic.Location)
  Let(pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  Sequence(exprs~ : @list.List[Expr], last_expr~ : Expr, loc~ : @basic.Location)
  Tuple(exprs~ : @list.List[Expr], loc~ : @basic.Location)
  Record(type_name~ : TypeName?, fields~ : @list.List[FieldDef], trailing~ : TrailingMark, loc~ : @basic.Location)
  RecordUpdate(type_name~ : TypeName?, record~ : Expr, fields~ : @list.List[FieldDef], loc~ : @basic.Location)
  Field(record~ : Expr, accessor~ : Accessor, loc~ : @basic.Location)
  Method(type_name~ : TypeName, method_name~ : Label, loc~ : @basic.Location)
  DotApply(self~ : Expr, method_name~ : Label, args~ : @list.List[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @basic.Location)
  As(expr~ : Expr, trait_~ : TypeName, loc~ : @basic.Location)
  Mutate(record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location)
  Match(expr~ : Expr, cases~ : @list.List[Case], match_loc~ : @basic.Location, using_~ : Label?, loc~ : @basic.Location)
  LetMut(binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @basic.Location)
  Pipe(lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location)
  Assign(var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location)
  Hole(loc~ : @basic.Location, kind~ : Hole)
  Return(return_value~ : Expr?, loc~ : @basic.Location)
  Raise(err_value~ : Expr, loc~ : @basic.Location)
  Unit(loc~ : @basic.Location, faked~ : Bool)
  Break(arg~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Continue(args~ : @list.List[Expr], label~ : Label?, loc~ : @basic.Location)
  Loop(args~ : @list.List[Expr], body~ : @list.List[MultiArgCase], label~ : Label?, loop_loc~ : @basic.Location, loc~ : @basic.Location)
  For(binders~ : @list.List[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.List[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  ForEach(binders~ : @list.List[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @basic.Location)
  Try(body~ : Expr, catch_~ : @list.List[Case], catch_all~ : Bool, try_else~ : @list.List[Case]?, has_try~ : Bool, try_loc~ : @basic.Location, catch_loc~ : @basic.Location, else_loc~ : @basic.Location, loc~ : @basic.Location)
  TryOperator(body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @basic.Location, loc~ : @basic.Location)
  Map(elems~ : @list.List[MapExprElem], loc~ : @basic.Location)
  Group(expr~ : Expr, group~ : Group, loc~ : @basic.Location)
  StaticAssert(asserts~ : @list.List[StaticAssertion], body~ : Expr)
}
fn Expr::loc(Self) -> @basic.Location
impl ToJson for Expr

pub(all) struct FieldDecl {
  name : FieldName
  ty : Type
  mut_ : Bool
  vis : Visibility
  loc : @basic.Location
  attrs : @list.List[@attribute.Attribute]
  mut doc : DocString
}
impl ToJson for FieldDecl

pub(all) struct FieldDef {
  label : Label
  expr : Expr
  is_pun : Bool
  loc : @basic.Location
}
impl ToJson for FieldDef

pub(all) struct FieldName {
  label : String
  loc : @basic.Location
}
impl ToJson for FieldName

pub(all) struct FieldPat {
  label : Label
  pattern : Pattern
  is_pun : Bool
  loc : @basic.Location
}
impl ToJson for FieldPat

pub(all) enum FnKind {
  Lambda
  Matrix
  Arrow
}
impl ToJson for FnKind

pub(all) struct FunDecl {
  type_name : TypeName?
  name : Binder
  has_error : @basic.Location?
  is_async : Bool
  decl_params : @list.List[Parameter]?
  params_loc : @basic.Location
  quantifiers : @list.List[TypeVarBinder]
  return_type : Type?
  error_type : ErrorType
  vis : Visibility
  attrs : @list.List[@attribute.Attribute]
  mut doc : DocString
}
impl ToJson for FunDecl

pub(all) enum Func {
  Lambda(parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, return_type~ : Type?, error_type~ : ErrorType, kind~ : FnKind, has_error~ : @basic.Location?, is_async~ : Bool, loc~ : @basic.Location)
  Match(cases~ : @list.List[MultiArgCase], has_error~ : @basic.Location?, is_async~ : Bool, fn_loc~ : @basic.Location, loc~ : @basic.Location)
}
impl ToJson for Func

pub(all) enum FuncStubs {
  Import(module_name~ : String, func_name~ : String)
  Embedded(language~ : String?, code~ : EmbeddedCode)
}
impl ToJson for FuncStubs

pub(all) enum Group {
  Brace
  Paren
}
impl ToJson for Group

pub(all) enum Hole {
  Synthesized
  Incomplete
  Todo
}
impl ToJson for Hole

pub(all) enum Impl {
  TopExpr(expr~ : Expr, is_main~ : Bool, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location)
  TopTest(expr~ : Expr, name~ : (String, @basic.Location)?, params~ : @list.List[Parameter]?, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], mut doc~ : DocString)
  TopTypeDef(TypeDecl)
  TopFuncDef(fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @basic.Location)
  TopFuncAlias(pkg~ : Label?, type_name~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, mut doc~ : DocString, loc~ : @basic.Location)
  TopLetDef(binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], mut doc~ : DocString)
  TopTrait(TraitDecl)
  TopBatchTypeAlias(pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, mut doc~ : DocString)
  TopBatchTraitAlias(pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, mut doc~ : DocString)
  TopImpl(self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @basic.Location?, quantifiers~ : @list.List[TypeVarBinder], params~ : @list.List[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], mut doc~ : DocString)
  TopView(quantifiers~ : @list.List[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @basic.Location, view_constrs~ : @list.List[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], mut doc~ : DocString)
  TopImplRelation(self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.List[TypeVarBinder], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], loc~ : @basic.Location, mut doc~ : DocString)
}
fn Impl::loc(Self) -> @basic.Location
impl ToJson for Impl

pub(all) enum InterpElem {
  Literal(repr~ : String, loc~ : @basic.Location)
  Expr(expr~ : Expr, loc~ : @basic.Location)
  Source(@tokens.InterpSource)
}
impl ToJson for InterpElem

pub(all) enum InterpolationComponent {
  InterpLit(String, @basic.Location)
  InterpSource(@tokens.InterpSource)
}

pub struct IterVisitorBase[T](T)
fn[T] IterVisitorBase::inner(Self[T]) -> T
impl[T : IterVisitor] IterVisitor for IterVisitorBase[T]

pub(all) struct Label {
  name : String
  loc : @basic.Location
}
impl ToJson for Label

pub(all) struct LocalTypeDecl {
  tycon : String
  tycon_loc : @basic.Location
  components : TypeDesc
  deriving : @list.List[DerivingDirective]
}
impl ToJson for LocalTypeDecl

pub(all) enum LongIdent {
  Ident(name~ : String)
  Dot(pkg~ : String, id~ : String)
}
fn LongIdent::dummy() -> Self
impl ToJson for LongIdent

pub(all) struct MapExprElem {
  key : Constant
  expr : Expr
  key_loc : @basic.Location
  loc : @basic.Location
}
impl ToJson for MapExprElem

pub(all) struct MapPatElem {
  key : Constant
  pat : Pattern
  match_absent : Bool
  key_loc : @basic.Location
  loc : @basic.Location
}
impl ToJson for MapPatElem

pub(all) struct MapVisitorBase[T](T)
fn[T] MapVisitorBase::inner(Self[T]) -> T
impl[T : MapVisitor] MapVisitor for MapVisitorBase[T]

pub(all) struct MultiArgCase {
  patterns : @list.List[Pattern]
  guard_ : Expr?
  body : Expr
}
impl ToJson for MultiArgCase

pub(all) enum MultilineStringElem {
  String(String)
  Interp(@list.List[InterpElem])
}
impl ToJson for MultilineStringElem

pub(all) enum Parameter {
  DiscardPositional(ty~ : Type?, loc~ : @basic.Location)
  Positional(binder~ : Binder, ty~ : Type?)
  Labelled(binder~ : Binder, ty~ : Type?)
  Optional(binder~ : Binder, default~ : Expr, ty~ : Type?)
  QuestionOptional(binder~ : Binder, ty~ : Type?)
}
fn Parameter::loc(Self) -> @basic.Location
impl ToJson for Parameter

pub(all) enum Pattern {
  Alias(pat~ : Pattern, alias_~ : Binder, loc~ : @basic.Location)
  Any(loc~ : @basic.Location)
  Array(pats~ : ArrayPatterns, loc~ : @basic.Location)
  Constant(c~ : Constant, loc~ : @basic.Location)
  Constraint(pat~ : Pattern, ty~ : Type, loc~ : @basic.Location)
  Constr(constr~ : Constructor, args~ : @list.List[ConstrPatArg]?, is_open~ : Bool, loc~ : @basic.Location)
  Or(pat1~ : Pattern, pat2~ : Pattern, loc~ : @basic.Location)
  Tuple(pats~ : @list.List[Pattern], loc~ : @basic.Location)
  Var(Binder)
  Record(fields~ : @list.List[FieldPat], is_closed~ : Bool, loc~ : @basic.Location)
  Map(elems~ : @list.List[MapPatElem], is_closed~ : Bool, loc~ : @basic.Location)
  Range(lhs~ : Pattern, rhs~ : Pattern, inclusive~ : Bool, loc~ : @basic.Location)
  SpecialConstr(binder~ : Binder, args~ : @list.List[ConstrPatArg], loc~ : @basic.Location)
}
fn Pattern::loc(Self) -> @basic.Location
impl ToJson for Pattern

pub(all) enum SpreadableElem {
  Regular(Expr)
  Spread(expr~ : Expr, loc~ : @basic.Location)
}
impl ToJson for SpreadableElem

pub(all) struct StaticAssertion {
  ty : Type
  trait_ : LongIdent
  loc : @basic.Location
  msg : String
}
impl ToJson for StaticAssertion

pub(all) enum TrailingMark {
  Comma
  Semi
  None
}
impl ToJson for TrailingMark

pub(all) struct TraitDecl {
  name : Binder
  supers : @list.List[TypeVarConstraint]
  methods : @list.List[TraitMethodDecl]
  vis : Visibility
  loc : @basic.Location
  attrs : @list.List[@attribute.Attribute]
  mut doc : DocString
}
impl ToJson for TraitDecl

pub(all) struct TraitMethodDecl {
  name : Binder
  has_error : @basic.Location?
  is_async : Bool
  quantifiers : @list.List[TypeVarBinder]
  params : @list.List[Parameter]
  return_type : Type?
  error_type : ErrorType
  has_default : @basic.Location?
  attrs : @list.List[@attribute.Attribute]
  loc : @basic.Location
}
impl ToJson for TraitMethodDecl

pub(all) enum TryOperatorKind {
  Question
  Exclamation
}
impl ToJson for TryOperatorKind

pub(all) enum Type {
  Any(loc~ : @basic.Location)
  Arrow(args~ : @list.List[Type], res~ : Type, err~ : ErrorType, is_async~ : Bool, loc~ : @basic.Location)
  Tuple(tys~ : @list.List[Type], loc~ : @basic.Location)
  Name(constr_id~ : ConstrId, tys~ : @list.List[Type], loc~ : @basic.Location)
  Option(ty~ : Type, loc~ : @basic.Location, question_loc~ : @basic.Location)
  Object(ConstrId)
}
fn Type::loc(Self) -> @basic.Location
impl ToJson for Type

pub(all) struct TypeDecl {
  tycon : String
  tycon_loc : @basic.Location
  params : @list.List[TypeDeclBinder]
  components : TypeDesc
  attrs : @list.List[@attribute.Attribute]
  mut doc : DocString
  type_vis : Visibility
  deriving : @list.List[DerivingDirective]
  loc : @basic.Location
}
impl ToJson for TypeDecl

pub(all) struct TypeDeclBinder {
  name : String?
  loc : @basic.Location
}
impl ToJson for TypeDeclBinder

pub(all) enum TypeDesc {
  Abstract
  Extern
  Newtype(Type)
  Error(ExceptionDecl)
  Variant(@list.List[ConstrDecl])
  Record(@list.List[FieldDecl])
  TupleStruct(@list.List[Type])
  Alias(Type)
}
impl ToJson for TypeDesc

pub(all) struct TypeName {
  name : LongIdent
  is_object : Bool
  loc : @basic.Location
}
impl ToJson for TypeName

pub(all) struct TypeVarBinder {
  name : String
  name_loc : @basic.Location
  constraints : @list.List[TypeVarConstraint]
}
impl ToJson for TypeVarBinder

pub(all) struct TypeVarConstraint {
  trait_ : LongIdent
  loc : @basic.Location
}
impl ToJson for TypeVarConstraint

pub(all) struct Var {
  name : LongIdent
  loc : @basic.Location
}
impl ToJson for Var

pub(all) enum Visibility {
  Default
  Pub(attr~ : String?, loc~ : @basic.Location)
  Priv(loc~ : @basic.Location)
}
impl ToJson for Visibility

// Type aliases
pub typealias @list.List[Impl] as Impls

pub typealias @list.List[Parameter] as Parameters

pub typealias (String, @basic.Location)? as TestName

// Traits
pub(open) trait IterVisitor {
  base(Self) -> IterVisitorBase[Self] = _
  visit_Visibility(Self, Visibility) -> Unit = _
  visit_Visibility_Pub(Self, attr~ : String?, loc~ : @basic.Location) -> Unit = _
  visit_Visibility_Priv(Self, loc~ : @basic.Location) -> Unit = _
  visit_Constant(Self, Constant) -> Unit = _
  visit_Label(Self, Label) -> Unit = _
  visit_ConstrName(Self, ConstrName) -> Unit = _
  visit_LongIdent(Self, LongIdent) -> Unit = _
  visit_LongIdent_Ident(Self, name~ : String) -> Unit = _
  visit_LongIdent_Dot(Self, pkg~ : String, id~ : String) -> Unit = _
  visit_TypeName(Self, TypeName) -> Unit = _
  visit_ConstrId(Self, ConstrId) -> Unit = _
  visit_Type(Self, Type) -> Unit = _
  visit_Type_Any(Self, loc~ : @basic.Location) -> Unit = _
  visit_Type_Arrow(Self, args~ : @list.List[Type], res~ : Type, err~ : ErrorType, is_async~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Type_Name(Self, constr_id~ : ConstrId, tys~ : @list.List[Type], loc~ : @basic.Location) -> Unit = _
  visit_Type_Tuple(Self, tys~ : @list.List[Type], loc~ : @basic.Location) -> Unit = _
  visit_Type_Option(Self, ty~ : Type, loc~ : @basic.Location, question_loc~ : @basic.Location) -> Unit = _
  visit_Type_Object(Self, ConstrId) -> Unit = _
  visit_ErrorType(Self, ErrorType) -> Unit = _
  visit_ErrorType_ErrorType(Self, ty~ : Type) -> Unit = _
  visit_ErrorType_DefaultErrorType(Self, loc~ : @basic.Location) -> Unit = _
  visit_ErrorType_MaybeError(Self, ty~ : Type) -> Unit = _
  visit_ConstrParam(Self, ConstrParam) -> Unit = _
  visit_ConstrDecl(Self, ConstrDecl) -> Unit = _
  visit_ExceptionDecl(Self, ExceptionDecl) -> Unit = _
  visit_ExceptionDecl_SinglePayload(Self, Type) -> Unit = _
  visit_ExceptionDecl_EnumPayload(Self, @list.List[ConstrDecl]) -> Unit = _
  visit_FieldName(Self, FieldName) -> Unit = _
  visit_FieldDecl(Self, FieldDecl) -> Unit = _
  visit_TypeDesc(Self, TypeDesc) -> Unit = _
  visit_TypeDesc_Newtype(Self, Type) -> Unit = _
  visit_TypeDesc_Error(Self, ExceptionDecl) -> Unit = _
  visit_TypeDesc_Variant(Self, @list.List[ConstrDecl]) -> Unit = _
  visit_TypeDesc_Record(Self, @list.List[FieldDecl]) -> Unit = _
  visit_TypeDesc_TupleStruct(Self, @list.List[Type]) -> Unit = _
  visit_TypeDesc_Alias(Self, Type) -> Unit = _
  visit_Hole(Self, Hole) -> Unit = _
  visit_ArgumentKind(Self, ArgumentKind) -> Unit = _
  visit_ArgumentKind_Labelled(Self, Label) -> Unit = _
  visit_ArgumentKind_LabelledPun(Self, Label) -> Unit = _
  visit_ArgumentKind_LabelledOption(Self, label~ : Label, question_loc~ : @basic.Location) -> Unit = _
  visit_ArgumentKind_LabelledOptionPun(Self, label~ : Label, question_loc~ : @basic.Location) -> Unit = _
  visit_FnKind(Self, FnKind) -> Unit = _
  visit_Group(Self, Group) -> Unit = _
  visit_TrailingMark(Self, TrailingMark) -> Unit = _
  visit_ApplyAttr(Self, ApplyAttr) -> Unit = _
  visit_TypeVarConstraint(Self, TypeVarConstraint) -> Unit = _
  visit_TypeVarBinder(Self, TypeVarBinder) -> Unit = _
  visit_TypeDeclBinder(Self, TypeDeclBinder) -> Unit = _
  visit_Binder(Self, Binder) -> Unit = _
  visit_Var(Self, Var) -> Unit = _
  visit_ConstructorExtraInfo(Self, ConstructorExtraInfo) -> Unit = _
  visit_ConstructorExtraInfo_TypeName(Self, TypeName) -> Unit = _
  visit_ConstructorExtraInfo_Package(Self, String) -> Unit = _
  visit_Constructor(Self, Constructor) -> Unit = _
  visit_Accessor(Self, Accessor) -> Unit = _
  visit_Accessor_Label(Self, Label) -> Unit = _
  visit_Accessor_Index(Self, tuple_index~ : Int, loc~ : @basic.Location) -> Unit = _
  visit_Accessor_Newtype(Self, loc~ : @basic.Location) -> Unit = _
  visit_AliasTarget(Self, AliasTarget) -> Unit = _
  visit_Argument(Self, Argument) -> Unit = _
  visit_Parameter(Self, Parameter) -> Unit = _
  visit_Parameter_DiscardPositional(Self, ty~ : Type?, loc~ : @basic.Location) -> Unit = _
  visit_Parameter_Positional(Self, binder~ : Binder, ty~ : Type?) -> Unit = _
  visit_Parameter_Labelled(Self, binder~ : Binder, ty~ : Type?) -> Unit = _
  visit_Parameter_Optional(Self, binder~ : Binder, default~ : Expr, ty~ : Type?) -> Unit = _
  visit_Parameter_QuestionOptional(Self, binder~ : Binder, ty~ : Type?) -> Unit = _
  visit_Case(Self, Case) -> Unit = _
  visit_MultiArgCase(Self, MultiArgCase) -> Unit = _
  visit_SpreadableElem(Self, SpreadableElem) -> Unit = _
  visit_SpreadableElem_Regular(Self, Expr) -> Unit = _
  visit_SpreadableElem_Spread(Self, expr~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_MapExprElem(Self, MapExprElem) -> Unit = _
  visit_StaticAssertion(Self, StaticAssertion) -> Unit = _
  visit_Func(Self, Func) -> Unit = _
  visit_Func_Lambda(Self, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, return_type~ : Type?, error_type~ : ErrorType, kind~ : FnKind, has_error~ : @basic.Location?, is_async~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Func_Match(Self, cases~ : @list.List[MultiArgCase], has_error~ : @basic.Location?, is_async~ : Bool, fn_loc~ : @basic.Location, loc~ : @basic.Location) -> Unit = _
  visit_FieldDef(Self, FieldDef) -> Unit = _
  visit_InterpElem(Self, InterpElem) -> Unit = _
  visit_InterpElem_Literal(Self, repr~ : String, loc~ : @basic.Location) -> Unit = _
  visit_InterpElem_Expr(Self, expr~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_InterpElem_Source(Self, @tokens.InterpSource) -> Unit = _
  visit_MultilineStringElem(Self, MultilineStringElem) -> Unit = _
  visit_MultilineStringElem_String(Self, String) -> Unit = _
  visit_MultilineStringElem_Interp(Self, @list.List[InterpElem]) -> Unit = _
  visit_TryOperatorKind(Self, TryOperatorKind) -> Unit = _
  visit_DotDotBinder(Self, DotDotBinder) -> Unit = _
  visit_DotDotBinder_BinderAs(Self, Binder) -> Unit = _
  visit_DotDotBinder_Binder(Self, Binder) -> Unit = _
  visit_ArrayPattern(Self, ArrayPattern) -> Unit = _
  visit_ArrayPattern_Pattern(Self, Pattern) -> Unit = _
  visit_ArrayPattern_StringSpread(Self, String) -> Unit = _
  visit_ArrayPattern_BytesSpread(Self, String) -> Unit = _
  visit_ArrayPattern_ConstSpread(Self, binder~ : Binder, pkg~ : String?, loc~ : @basic.Location) -> Unit = _
  visit_ArrayPatterns(Self, ArrayPatterns) -> Unit = _
  visit_ArrayPatterns_Closed(Self, @list.List[ArrayPattern]) -> Unit = _
  visit_ArrayPatterns_Open(Self, @list.List[ArrayPattern], @list.List[ArrayPattern], DotDotBinder) -> Unit = _
  visit_FieldPat(Self, FieldPat) -> Unit = _
  visit_ConstrPatArg(Self, ConstrPatArg) -> Unit = _
  visit_MapPatElem(Self, MapPatElem) -> Unit = _
  visit_Pattern(Self, Pattern) -> Unit = _
  visit_Pattern_Alias(Self, pat~ : Pattern, alias_~ : Binder, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Any(Self, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Array(Self, pats~ : ArrayPatterns, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Constant(Self, c~ : Constant, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Constraint(Self, pat~ : Pattern, ty~ : Type, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Constr(Self, constr~ : Constructor, args~ : @list.List[ConstrPatArg]?, is_open~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Or(Self, pat1~ : Pattern, pat2~ : Pattern, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Tuple(Self, pats~ : @list.List[Pattern], loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Var(Self, Binder) -> Unit = _
  visit_Pattern_Record(Self, fields~ : @list.List[FieldPat], is_closed~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Map(Self, elems~ : @list.List[MapPatElem], is_closed~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_Range(Self, lhs~ : Pattern, rhs~ : Pattern, inclusive~ : Bool, loc~ : @basic.Location) -> Unit = _
  visit_Pattern_SpecialConstr(Self, binder~ : Binder, args~ : @list.List[ConstrPatArg], loc~ : @basic.Location) -> Unit = _
  visit_LocalTypeDecl(Self, LocalTypeDecl) -> Unit = _
  visit_DerivingDirective(Self, DerivingDirective) -> Unit = _
  visit_TypeDecl(Self, TypeDecl) -> Unit = _
  visit_FuncStubs(Self, FuncStubs) -> Unit = _
  visit_FuncStubs_Import(Self, module_name~ : String, func_name~ : String) -> Unit = _
  visit_FuncStubs_Embedded(Self, language~ : String?, code~ : EmbeddedCode) -> Unit = _
  visit_EmbeddedCode(Self, EmbeddedCode) -> Unit = _
  visit_EmbeddedCode_CodeString(Self, String) -> Unit = _
  visit_EmbeddedCode_CodeMultilineString(Self, @list.List[String]) -> Unit = _
  visit_DeclBody(Self, DeclBody) -> Unit = _
  visit_DeclBody_DeclBody(Self, local_types~ : @list.List[LocalTypeDecl], expr~ : Expr) -> Unit = _
  visit_DeclBody_DeclStubs(Self, FuncStubs) -> Unit = _
  visit_FunDecl(Self, FunDecl) -> Unit = _
  visit_TraitMethodDecl(Self, TraitMethodDecl) -> Unit = _
  visit_TraitDecl(Self, TraitDecl) -> Unit = _
  visit_Impl(Self, Impl) -> Unit = _
  visit_Impl_TopExpr(Self, expr~ : Expr, is_main~ : Bool, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location) -> Unit = _
  visit_Impl_TopTest(Self, expr~ : Expr, name~ : (String, @basic.Location)?, params~ : @list.List[Parameter]?, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Unit = _
  visit_Impl_TopTypeDef(Self, TypeDecl) -> Unit = _
  visit_Impl_TopFuncDef(Self, fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @basic.Location) -> Unit = _
  visit_Impl_TopFuncAlias(Self, pkg~ : Label?, type_name~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString, loc~ : @basic.Location) -> Unit = _
  visit_Impl_TopLetDef(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Unit = _
  visit_Impl_TopTrait(Self, TraitDecl) -> Unit = _
  visit_Impl_TopBatchTypeAlias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString) -> Unit = _
  visit_Impl_TopBatchTraitAlias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString) -> Unit = _
  visit_Impl_TopImpl(Self, self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @basic.Location?, quantifiers~ : @list.List[TypeVarBinder], params~ : @list.List[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Unit = _
  visit_Impl_TopView(Self, quantifiers~ : @list.List[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @basic.Location, view_constrs~ : @list.List[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Unit = _
  visit_Impl_TopImplRelation(Self, self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.List[TypeVarBinder], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], loc~ : @basic.Location, doc~ : DocString) -> Unit = _
  visit_Expr(Self, Expr) -> Unit = _
  visit_Expr_Apply(Self, func~ : Expr, args~ : @list.List[Argument], attr~ : ApplyAttr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Infix(Self, op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Unary(Self, op~ : Var, expr~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Array(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Unit = _
  visit_Expr_ArraySpread(Self, elems~ : @list.List[SpreadableElem], loc~ : @basic.Location) -> Unit = _
  visit_Expr_ArrayGet(Self, array~ : Expr, index~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_ArrayGetSlice(Self, array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @basic.Location, loc~ : @basic.Location) -> Unit = _
  visit_Expr_ArraySet(Self, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_ArrayAugmentedSet(Self, op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Constant(Self, c~ : Constant, loc~ : @basic.Location) -> Unit = _
  visit_Expr_MultilineString(Self, elems~ : @list.List[MultilineStringElem], loc~ : @basic.Location) -> Unit = _
  visit_Expr_Interp(Self, elems~ : @list.List[InterpElem], loc~ : @basic.Location) -> Unit = _
  visit_Expr_Constraint(Self, expr~ : Expr, ty~ : Type, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Constr(Self, constr~ : Constructor, loc~ : @basic.Location) -> Unit = _
  visit_Expr_While(Self, loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Function(Self, func~ : Func, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Ident(Self, id~ : Var, loc~ : @basic.Location) -> Unit = _
  visit_Expr_If(Self, cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Guard(Self, cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Is(Self, expr~ : Expr, pat~ : Pattern, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Defer(Self, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_LetFn(Self, name~ : Binder, func~ : Func, body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_LetRec(Self, bindings~ : @list.List[(Binder, Func)], body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_LetAnd(Self, bindings~ : @list.List[(Binder, Type?, Func)], body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Let(Self, pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Sequence(Self, exprs~ : @list.List[Expr], last_expr~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Tuple(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Unit = _
  visit_Expr_Record(Self, type_name~ : TypeName?, fields~ : @list.List[FieldDef], trailing~ : TrailingMark, loc~ : @basic.Location) -> Unit = _
  visit_Expr_RecordUpdate(Self, type_name~ : TypeName?, record~ : Expr, fields~ : @list.List[FieldDef], loc~ : @basic.Location) -> Unit = _
  visit_Expr_Field(Self, record~ : Expr, accessor~ : Accessor, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Method(Self, type_name~ : TypeName, method_name~ : Label, loc~ : @basic.Location) -> Unit = _
  visit_Expr_DotApply(Self, self~ : Expr, method_name~ : Label, args~ : @list.List[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_As(Self, expr~ : Expr, trait_~ : TypeName, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Mutate(Self, record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Match(Self, expr~ : Expr, cases~ : @list.List[Case], match_loc~ : @basic.Location, using_~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_LetMut(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Pipe(Self, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Assign(Self, var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Hole(Self, loc~ : @basic.Location, kind~ : Hole) -> Unit = _
  visit_Expr_Return(Self, return_value~ : Expr?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Raise(Self, err_value~ : Expr, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Unit(Self, loc~ : @basic.Location, faked~ : Bool) -> Unit = _
  visit_Expr_Break(Self, arg~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Continue(Self, args~ : @list.List[Expr], label~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Loop(Self, args~ : @list.List[Expr], body~ : @list.List[MultiArgCase], label~ : Label?, loop_loc~ : @basic.Location, loc~ : @basic.Location) -> Unit = _
  visit_Expr_For(Self, binders~ : @list.List[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.List[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_ForEach(Self, binders~ : @list.List[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Try(Self, body~ : Expr, catch_~ : @list.List[Case], catch_all~ : Bool, try_else~ : @list.List[Case]?, has_try~ : Bool, try_loc~ : @basic.Location, catch_loc~ : @basic.Location, else_loc~ : @basic.Location, loc~ : @basic.Location) -> Unit = _
  visit_Expr_TryOperator(Self, body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @basic.Location, loc~ : @basic.Location) -> Unit = _
  visit_Expr_Map(Self, elems~ : @list.List[MapExprElem], loc~ : @basic.Location) -> Unit = _
  visit_Expr_Group(Self, expr~ : Expr, group~ : Group, loc~ : @basic.Location) -> Unit = _
  visit_Expr_StaticAssert(Self, asserts~ : @list.List[StaticAssertion], body~ : Expr) -> Unit = _
}

pub(open) trait MapVisitor {
  base(Self) -> MapVisitorBase[Self] = _
  visit_Visibility(Self, Visibility) -> Visibility = _
  visit_Visibility_Pub(Self, attr~ : String?, loc~ : @basic.Location) -> Visibility = _
  visit_Visibility_Priv(Self, loc~ : @basic.Location) -> Visibility = _
  visit_Constant(Self, Constant) -> Constant = _
  visit_Label(Self, Label) -> Label = _
  visit_ConstrName(Self, ConstrName) -> ConstrName = _
  visit_LongIdent(Self, LongIdent) -> LongIdent = _
  visit_LongIdent_Ident(Self, name~ : String) -> LongIdent = _
  visit_LongIdent_Dot(Self, pkg~ : String, id~ : String) -> LongIdent = _
  visit_TypeName(Self, TypeName) -> TypeName = _
  visit_ConstrId(Self, ConstrId) -> ConstrId = _
  visit_Type(Self, Type) -> Type = _
  visit_Type_Any(Self, loc~ : @basic.Location) -> Type = _
  visit_Type_Arrow(Self, args~ : @list.List[Type], res~ : Type, err~ : ErrorType, is_async~ : Bool, loc~ : @basic.Location) -> Type = _
  visit_Type_Tuple(Self, tys~ : @list.List[Type], loc~ : @basic.Location) -> Type = _
  visit_Type_Name(Self, constr_id~ : ConstrId, tys~ : @list.List[Type], loc~ : @basic.Location) -> Type = _
  visit_Type_Option(Self, ty~ : Type, loc~ : @basic.Location, question_loc~ : @basic.Location) -> Type = _
  visit_Type_Object(Self, ConstrId) -> Type = _
  visit_ErrorType(Self, ErrorType) -> ErrorType = _
  visit_ErrorType_ErrorType(Self, ty~ : Type) -> ErrorType = _
  visit_ErrorType_DefaultErrorType(Self, loc~ : @basic.Location) -> ErrorType = _
  visit_ErrorType_MaybeError(Self, ty~ : Type) -> ErrorType = _
  visit_ConstrParam(Self, ConstrParam) -> ConstrParam = _
  visit_ConstrDecl(Self, ConstrDecl) -> ConstrDecl = _
  visit_ExceptionDecl(Self, ExceptionDecl) -> ExceptionDecl = _
  visit_ExceptionDecl_SinglePayload(Self, Type) -> ExceptionDecl = _
  visit_ExceptionDecl_EnumPayload(Self, @list.List[ConstrDecl]) -> ExceptionDecl = _
  visit_FieldName(Self, FieldName) -> FieldName = _
  visit_FieldDecl(Self, FieldDecl) -> FieldDecl = _
  visit_TypeDesc(Self, TypeDesc) -> TypeDesc = _
  visit_TypeDesc_Newtype(Self, Type) -> TypeDesc = _
  visit_TypeDesc_Error(Self, ExceptionDecl) -> TypeDesc = _
  visit_TypeDesc_Variant(Self, @list.List[ConstrDecl]) -> TypeDesc = _
  visit_TypeDesc_Record(Self, @list.List[FieldDecl]) -> TypeDesc = _
  visit_TypeDesc_TupleStruct(Self, @list.List[Type]) -> TypeDesc = _
  visit_TypeDesc_Alias(Self, Type) -> TypeDesc = _
  visit_Hole(Self, Hole) -> Hole = _
  visit_ArgumentKind(Self, ArgumentKind) -> ArgumentKind = _
  visit_ArgumentKind_Labelled(Self, Label) -> ArgumentKind = _
  visit_ArgumentKind_LabelledPun(Self, Label) -> ArgumentKind = _
  visit_ArgumentKind_LabelledOption(Self, label~ : Label, question_loc~ : @basic.Location) -> ArgumentKind = _
  visit_ArgumentKind_LabelledOptionPun(Self, label~ : Label, question_loc~ : @basic.Location) -> ArgumentKind = _
  visit_FnKind(Self, FnKind) -> FnKind = _
  visit_Group(Self, Group) -> Group = _
  visit_TrailingMark(Self, TrailingMark) -> TrailingMark = _
  visit_ApplyAttr(Self, ApplyAttr) -> ApplyAttr = _
  visit_TypeVarConstraint(Self, TypeVarConstraint) -> TypeVarConstraint = _
  visit_TypeVarBinder(Self, TypeVarBinder) -> TypeVarBinder = _
  visit_TypeDeclBinder(Self, TypeDeclBinder) -> TypeDeclBinder = _
  visit_Binder(Self, Binder) -> Binder = _
  visit_Var(Self, Var) -> Var = _
  visit_ConstructorExtraInfo(Self, ConstructorExtraInfo) -> ConstructorExtraInfo = _
  visit_ConstructorExtraInfo_TypeName(Self, TypeName) -> ConstructorExtraInfo = _
  visit_ConstructorExtraInfo_Package(Self, String) -> ConstructorExtraInfo = _
  visit_Constructor(Self, Constructor) -> Constructor = _
  visit_Accessor(Self, Accessor) -> Accessor = _
  visit_Accessor_Label(Self, Label) -> Accessor = _
  visit_Accessor_Index(Self, tuple_index~ : Int, loc~ : @basic.Location) -> Accessor = _
  visit_Accessor_Newtype(Self, loc~ : @basic.Location) -> Accessor = _
  visit_AliasTarget(Self, AliasTarget) -> AliasTarget = _
  visit_Argument(Self, Argument) -> Argument = _
  visit_Parameter(Self, Parameter) -> Parameter = _
  visit_Parameter_DiscardPositional(Self, ty~ : Type?, loc~ : @basic.Location) -> Parameter = _
  visit_Parameter_Positional(Self, binder~ : Binder, ty~ : Type?) -> Parameter = _
  visit_Parameter_Labelled(Self, binder~ : Binder, ty~ : Type?) -> Parameter = _
  visit_Parameter_Optional(Self, binder~ : Binder, default~ : Expr, ty~ : Type?) -> Parameter = _
  visit_Parameter_QuestionOptional(Self, binder~ : Binder, ty~ : Type?) -> Parameter = _
  visit_Case(Self, Case) -> Case = _
  visit_MultiArgCase(Self, MultiArgCase) -> MultiArgCase = _
  visit_SpreadableElem(Self, SpreadableElem) -> SpreadableElem = _
  visit_SpreadableElem_Regular(Self, Expr) -> SpreadableElem = _
  visit_SpreadableElem_Spread(Self, expr~ : Expr, loc~ : @basic.Location) -> SpreadableElem = _
  visit_MapExprElem(Self, MapExprElem) -> MapExprElem = _
  visit_StaticAssertion(Self, StaticAssertion) -> StaticAssertion = _
  visit_Func(Self, Func) -> Func = _
  visit_Func_Lambda(Self, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, return_type~ : Type?, error_type~ : ErrorType, kind~ : FnKind, has_error~ : @basic.Location?, is_async~ : Bool, loc~ : @basic.Location) -> Func = _
  visit_Func_Match(Self, cases~ : @list.List[MultiArgCase], has_error~ : @basic.Location?, is_async~ : Bool, fn_loc~ : @basic.Location, loc~ : @basic.Location) -> Func = _
  visit_FieldDef(Self, FieldDef) -> FieldDef = _
  visit_InterpElem(Self, InterpElem) -> InterpElem = _
  visit_InterpElem_Literal(Self, repr~ : String, loc~ : @basic.Location) -> InterpElem = _
  visit_InterpElem_Expr(Self, expr~ : Expr, loc~ : @basic.Location) -> InterpElem = _
  visit_InterpElem_Source(Self, @tokens.InterpSource) -> InterpElem = _
  visit_MultilineStringElem(Self, MultilineStringElem) -> MultilineStringElem = _
  visit_MultilineStringElem_String(Self, String) -> MultilineStringElem = _
  visit_MultilineStringElem_Interp(Self, @list.List[InterpElem]) -> MultilineStringElem = _
  visit_TryOperatorKind(Self, TryOperatorKind) -> TryOperatorKind = _
  visit_DotDotBinder(Self, DotDotBinder) -> DotDotBinder = _
  visit_DotDotBinder_BinderAs(Self, Binder) -> DotDotBinder = _
  visit_DotDotBinder_Binder(Self, Binder) -> DotDotBinder = _
  visit_ArrayPattern(Self, ArrayPattern) -> ArrayPattern = _
  visit_ArrayPattern_Pattern(Self, Pattern) -> ArrayPattern = _
  visit_ArrayPattern_StringSpread(Self, String) -> ArrayPattern = _
  visit_ArrayPattern_BytesSpread(Self, String) -> ArrayPattern = _
  visit_ArrayPattern_ConstSpread(Self, binder~ : Binder, pkg~ : String?, loc~ : @basic.Location) -> ArrayPattern = _
  visit_ArrayPatterns(Self, ArrayPatterns) -> ArrayPatterns = _
  visit_ArrayPatterns_Closed(Self, @list.List[ArrayPattern]) -> ArrayPatterns = _
  visit_ArrayPatterns_Open(Self, @list.List[ArrayPattern], @list.List[ArrayPattern], DotDotBinder) -> ArrayPatterns = _
  visit_FieldPat(Self, FieldPat) -> FieldPat = _
  visit_ConstrPatArg(Self, ConstrPatArg) -> ConstrPatArg = _
  visit_MapPatElem(Self, MapPatElem) -> MapPatElem = _
  visit_Pattern(Self, Pattern) -> Pattern = _
  visit_Pattern_Alias(Self, pat~ : Pattern, alias_~ : Binder, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Any(Self, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Array(Self, pats~ : ArrayPatterns, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Constant(Self, c~ : Constant, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Constraint(Self, pat~ : Pattern, ty~ : Type, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Constr(Self, constr~ : Constructor, args~ : @list.List[ConstrPatArg]?, is_open~ : Bool, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Or(Self, pat1~ : Pattern, pat2~ : Pattern, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Tuple(Self, pats~ : @list.List[Pattern], loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Var(Self, Binder) -> Pattern = _
  visit_Pattern_Record(Self, fields~ : @list.List[FieldPat], is_closed~ : Bool, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Map(Self, elems~ : @list.List[MapPatElem], is_closed~ : Bool, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_Range(Self, lhs~ : Pattern, rhs~ : Pattern, inclusive~ : Bool, loc~ : @basic.Location) -> Pattern = _
  visit_Pattern_SpecialConstr(Self, binder~ : Binder, args~ : @list.List[ConstrPatArg], loc~ : @basic.Location) -> Pattern = _
  visit_LocalTypeDecl(Self, LocalTypeDecl) -> LocalTypeDecl = _
  visit_DerivingDirective(Self, DerivingDirective) -> DerivingDirective = _
  visit_TypeDecl(Self, TypeDecl) -> TypeDecl = _
  visit_FuncStubs(Self, FuncStubs) -> FuncStubs = _
  visit_FuncStubs_Import(Self, module_name~ : String, func_name~ : String) -> FuncStubs = _
  visit_FuncStubs_Embedded(Self, language~ : String?, code~ : EmbeddedCode) -> FuncStubs = _
  visit_EmbeddedCode(Self, EmbeddedCode) -> EmbeddedCode = _
  visit_EmbeddedCode_CodeString(Self, String) -> EmbeddedCode = _
  visit_EmbeddedCode_CodeMultilineString(Self, @list.List[String]) -> EmbeddedCode = _
  visit_DeclBody(Self, DeclBody) -> DeclBody = _
  visit_DeclBody_DeclBody(Self, local_types~ : @list.List[LocalTypeDecl], expr~ : Expr) -> DeclBody = _
  visit_DeclBody_DeclStubs(Self, FuncStubs) -> DeclBody = _
  visit_FunDecl(Self, FunDecl) -> FunDecl = _
  visit_TraitMethodDecl(Self, TraitMethodDecl) -> TraitMethodDecl = _
  visit_TraitDecl(Self, TraitDecl) -> TraitDecl = _
  visit_Impl(Self, Impl) -> Impl = _
  visit_Impl_TopExpr(Self, expr~ : Expr, is_main~ : Bool, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location) -> Impl = _
  visit_Impl_TopTest(Self, expr~ : Expr, name~ : (String, @basic.Location)?, params~ : @list.List[Parameter]?, local_types~ : @list.List[LocalTypeDecl], loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Impl = _
  visit_Impl_TopTypeDef(Self, TypeDecl) -> Impl = _
  visit_Impl_TopFuncDef(Self, fun_decl~ : FunDecl, decl_body~ : DeclBody, loc~ : @basic.Location) -> Impl = _
  visit_Impl_TopFuncAlias(Self, pkg~ : Label?, type_name~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString, loc~ : @basic.Location) -> Impl = _
  visit_Impl_TopLetDef(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, vis~ : Visibility, is_constant~ : Bool, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Impl = _
  visit_Impl_TopTrait(Self, TraitDecl) -> Impl = _
  visit_Impl_TopBatchTypeAlias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString) -> Impl = _
  visit_Impl_TopBatchTraitAlias(Self, pkg~ : Label?, targets~ : @list.List[AliasTarget], vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], is_list~ : Bool, doc~ : DocString) -> Impl = _
  visit_Impl_TopImpl(Self, self_ty~ : Type?, trait_~ : TypeName, method_name~ : Binder, has_error~ : @basic.Location?, quantifiers~ : @list.List[TypeVarBinder], params~ : @list.List[Parameter], ret_ty~ : Type?, err_ty~ : ErrorType, body~ : DeclBody, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Impl = _
  visit_Impl_TopView(Self, quantifiers~ : @list.List[TypeVarBinder], source_ty~ : Type, view_type_name~ : String, view_type_loc~ : @basic.Location, view_constrs~ : @list.List[ConstrDecl], view_func_name~ : Binder, parameters~ : @list.List[Parameter], params_loc~ : @basic.Location, body~ : Expr, vis~ : Visibility, loc~ : @basic.Location, attrs~ : @list.List[@attribute.Attribute], doc~ : DocString) -> Impl = _
  visit_Impl_TopImplRelation(Self, self_ty~ : Type, trait_~ : TypeName, quantifiers~ : @list.List[TypeVarBinder], vis~ : Visibility, attrs~ : @list.List[@attribute.Attribute], loc~ : @basic.Location, doc~ : DocString) -> Impl = _
  visit_Expr(Self, Expr) -> Expr = _
  visit_Expr_Apply(Self, func~ : Expr, args~ : @list.List[Argument], attr~ : ApplyAttr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Infix(Self, op~ : Var, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Unary(Self, op~ : Var, expr~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Array(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Expr = _
  visit_Expr_ArraySpread(Self, elems~ : @list.List[SpreadableElem], loc~ : @basic.Location) -> Expr = _
  visit_Expr_ArrayGet(Self, array~ : Expr, index~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_ArrayGetSlice(Self, array~ : Expr, start_index~ : Expr?, end_index~ : Expr?, index_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_Expr_ArraySet(Self, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_ArrayAugmentedSet(Self, op~ : Var, array~ : Expr, index~ : Expr, value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Constant(Self, c~ : Constant, loc~ : @basic.Location) -> Expr = _
  visit_Expr_MultilineString(Self, elems~ : @list.List[MultilineStringElem], loc~ : @basic.Location) -> Expr = _
  visit_Expr_Interp(Self, elems~ : @list.List[InterpElem], loc~ : @basic.Location) -> Expr = _
  visit_Expr_Constraint(Self, expr~ : Expr, ty~ : Type, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Constr(Self, constr~ : Constructor, loc~ : @basic.Location) -> Expr = _
  visit_Expr_While(Self, loop_cond~ : Expr, loop_body~ : Expr, while_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Function(Self, func~ : Func, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Ident(Self, id~ : Var, loc~ : @basic.Location) -> Expr = _
  visit_Expr_If(Self, cond~ : Expr, ifso~ : Expr, ifnot~ : Expr?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Guard(Self, cond~ : Expr, otherwise~ : Expr?, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Is(Self, expr~ : Expr, pat~ : Pattern, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Defer(Self, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_LetFn(Self, name~ : Binder, func~ : Func, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_LetRec(Self, bindings~ : @list.List[(Binder, Func)], body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_LetAnd(Self, bindings~ : @list.List[(Binder, Type?, Func)], body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Let(Self, pattern~ : Pattern, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Sequence(Self, exprs~ : @list.List[Expr], last_expr~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Tuple(Self, exprs~ : @list.List[Expr], loc~ : @basic.Location) -> Expr = _
  visit_Expr_Record(Self, type_name~ : TypeName?, fields~ : @list.List[FieldDef], trailing~ : TrailingMark, loc~ : @basic.Location) -> Expr = _
  visit_Expr_RecordUpdate(Self, type_name~ : TypeName?, record~ : Expr, fields~ : @list.List[FieldDef], loc~ : @basic.Location) -> Expr = _
  visit_Expr_Field(Self, record~ : Expr, accessor~ : Accessor, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Method(Self, type_name~ : TypeName, method_name~ : Label, loc~ : @basic.Location) -> Expr = _
  visit_Expr_DotApply(Self, self~ : Expr, method_name~ : Label, args~ : @list.List[Argument], return_self~ : Bool, attr~ : ApplyAttr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_As(Self, expr~ : Expr, trait_~ : TypeName, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Mutate(Self, record~ : Expr, accessor~ : Accessor, field~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Match(Self, expr~ : Expr, cases~ : @list.List[Case], match_loc~ : @basic.Location, using_~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_LetMut(Self, binder~ : Binder, ty~ : Type?, expr~ : Expr, body~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Pipe(Self, lhs~ : Expr, rhs~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Assign(Self, var_~ : Var, expr~ : Expr, augmented_by~ : Var?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Hole(Self, loc~ : @basic.Location, kind~ : Hole) -> Expr = _
  visit_Expr_Return(Self, return_value~ : Expr?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Raise(Self, err_value~ : Expr, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Unit(Self, loc~ : @basic.Location, faked~ : Bool) -> Expr = _
  visit_Expr_Break(Self, arg~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Continue(Self, args~ : @list.List[Expr], label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Loop(Self, args~ : @list.List[Expr], body~ : @list.List[MultiArgCase], label~ : Label?, loop_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_Expr_For(Self, binders~ : @list.List[(Binder, Expr)], condition~ : Expr?, continue_block~ : @list.List[(Binder, Expr)], body~ : Expr, for_else~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_ForEach(Self, binders~ : @list.List[Binder?], expr~ : Expr, body~ : Expr, else_block~ : Expr?, label~ : Label?, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Try(Self, body~ : Expr, catch_~ : @list.List[Case], catch_all~ : Bool, try_else~ : @list.List[Case]?, has_try~ : Bool, try_loc~ : @basic.Location, catch_loc~ : @basic.Location, else_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_Expr_TryOperator(Self, body~ : Expr, kind~ : TryOperatorKind, try_loc~ : @basic.Location, loc~ : @basic.Location) -> Expr = _
  visit_Expr_Map(Self, elems~ : @list.List[MapExprElem], loc~ : @basic.Location) -> Expr = _
  visit_Expr_Group(Self, expr~ : Expr, group~ : Group, loc~ : @basic.Location) -> Expr = _
  visit_Expr_StaticAssert(Self, asserts~ : @list.List[StaticAssertion], body~ : Expr) -> Expr = _
}

