%derive<Show> Token
%derive<Eq> TokenKind
%derive<Hash> TokenKind
%derive<Compare> TokenKind
%position<Position>
%derive<Show> ParseError

%start structure
%start expression

%token<CharLiteral> CHAR
%token<String> INT
%token<CharLiteral> BYTE
%token<StringLiteral> BYTES
%token<String> FLOAT
%token<String> DOUBLE
%token<StringLiteral> STRING
%token<String> MULTILINE_STRING
%token<InterpLiteral> MULTILINE_INTERP
%token<InterpLiteral> INTERP
%token<(String, String?, String)> ATTRIBUTE
%token<String> LIDENT
%token<String> UIDENT
%token<String> POST_LABEL
%token<Comment> COMMENT
%token NEWLINE
%token<String> INFIX1
%token<String> INFIX2
%token<String> INFIX3
%token<String> INFIX4
%token<String> AUGMENTED_ASSIGNMENT
%token EOF
%token FALSE
%token TRUE
%token PUB "pub"
%token PRIV "priv"
%token READONLY "readonly"
%token IMPORT "import"
%token EXTERN "extern"
%token BREAK "break"
%token CONTINUE "continue"
%token STRUCT "struct"
%token ENUM "enum"
%token TRAIT "trait"
%token DERIVE "derive"
%token IMPL "impl"
%token WITH "with"
%token RAISE "raise"
%token THROW "throw"
%token TRY "try"
%token CATCH "catch"
%token ASYNC "async"
%token TYPEALIAS "typealias"
%token TRAITALIAS "traitalias"
%token FNALIAS "fnalias"
%token EQUAL "="
%token LPAREN "("
%token RPAREN ")"
%token COMMA ","
%token MINUS "-"
%token QUESTION "?"
%token EXCLAMATION "!"
%token<String> DOT_LIDENT
%token<String> DOT_UIDENT
%token<Int> DOT_INT
%token DOT_LPAREN ".("
%token COLONCOLON "::"
%token COLON ":"
%token<Bool> SEMI
%token LBRACKET "["
%token PLUS "+"
%token RBRACKET "]"
%token UNDERSCORE "_"
%token BAR "|"
%token LBRACE "{"
%token RBRACE "}"
%token AMPERAMPER "&&"
%token AMPER "&"
%token CARET "^"
%token BARBAR "||"
%token<String> PACKAGE_NAME
%token AS "as"
%token PIPE "|>"
%token ELSE "else"
%token FN "fn"
%token IF "if"
%token LET "let"
%token CONST "const"
%token MATCH "match"
%token USING "using"
%token MUTABLE "mut"
%token TYPE "type"
%token FAT_ARROW "=>"
%token THIN_ARROW "->"
%token WHILE "while"
%token RETURN "return"
%token DOTDOT ".."
%token RANGE_INCLUSIVE "..="
%token RANGE_EXCLUSIVE "..<"
%token ELLIPSIS "..."
%token TEST "test"
%token LOOP "loop"
%token GUARD "guard"
%token DEFER "defer"
%token FOR "for"
%token IN "in"
%token IS "is"
%token SUBERROR "suberror"
%token AND "and"
%token LETREC "letrec"
%token ENUMVIEW "enumview"
%token NORAISE "noraise"
%token TRY_QUESTION    "try?"
%token TRY_EXCLAMATION "try!"

%right BARBAR
%right AMPERAMPER
%left BAR
%left CARET
%left AMPER
%nonassoc prec_field
%nonassoc LPAREN
%left INFIX1
%left INFIX2
%left PLUS MINUS
%left INFIX3
%left INFIX4
%nonassoc prec_lower_than_as
%nonassoc "as"
%nonassoc prec_apply_non_ident_fn
%nonassoc "!"
%nonassoc "?"
%nonassoc prec_lower_than_arrow_fn
%nonassoc ","
%nonassoc ")"
%nonassoc ":"

%%


non_empty_list_rev[T](X : T) -> List[T]
  : X { @list.singleton($1) }
  | non_empty_list_rev(X) X { $1.add($2) }
  ;

non_empty_list[T](X : T) -> List[T] 
  : X { @list.singleton($1) }
  | X non_empty_list(X) { $2.add($1) }
  ;

non_empty_list_commas_rev[T](X : T) -> List[T]
  : X { @list.singleton($1) }
  | non_empty_list_commas_rev(X) "," X { $1.add($3) }
  ;

non_empty_list_commas_no_trailing[T](X : T) -> List[T]
  : non_empty_list_commas_rev(X) { $1.rev() }
  ;

non_empty_list_commas[T](X : T) -> List[T]
  : non_empty_list_commas_rev(X) option(",") { $1.rev() }
  ;

non_empty_list_commas_with_tail[T](X : T) -> List[T]
  : non_empty_list_commas_rev(X) "," { $1.rev() }
  ;

list_commas[T](X : T) -> List[T]
  : { @list.empty() }
  | non_empty_list_commas(X) { $1 }
  ;

list_commas_no_trailing[T](X : T) -> List[T]
  : { @list.empty() }
  | non_empty_list_commas_no_trailing(X) { $1 }
  ;

non_empty_list_commas_with_trailing_info[T](X : T) -> (List[T], Bool)
  : non_empty_list_commas_rev(X) option(",") { 
    ($1.rev(), $2 is Some(_)) 
  }
  ;

list_commas_with_trailing_info[T](X : T) -> (List[T], Bool)
  : { (@list.empty(), false) }
  | non_empty_list_commas_with_trailing_info(X) { $1 }
  ;

non_empty_list_semi_rev_aux[T](X : T) -> List[T]
  : X { @list.singleton($1) }
  | non_empty_list_semi_rev_aux(X) SEMI X { $1.add($3) }
  ;

non_empty_list_semis_rev[T](X : T) -> List[T]
  : non_empty_list_semi_rev_aux(X) option(SEMI) { $1 }
  ;

none_empty_list_semis_rev_with_trailing_info[T](X : T) -> (List[T], Bool)
  : non_empty_list_semi_rev_aux(X) option(SEMI) { ($1, $2 is Some(_)) }
  ;

non_empty_list_semis[T](X : T) -> List[T]
  : X option(SEMI) { @list.singleton($1) }
  | X SEMI non_empty_list_semis(X) { $3.add($1) }
  ;

list_semis_rev[T](X : T) -> List[T]
  : { @list.empty() }
  | non_empty_list_semis_rev(X) { $1 }
  ;

list_semis[T](X : T) -> List[T]
  : { @list.empty() }
  | non_empty_list_semis(X) { $1 }
  ;

%inline id[T](X : T) -> T
  : X { $1 }
  ;

%inline annot -> Type
  : ":" type_ { $2 }
  ;

%inline opt_annot -> Type?
  : ioption(annot) { $1 }
  ;

parameter -> Parameter
  : "_" opt_annot { DiscardPositional(ty = $2, loc = mk_loc($loc($1))) }
  | binder opt_annot { Positional(binder = $1, ty = $2) }
  | POST_LABEL opt_annot {
      let binder = Binder::{ name: $1, loc: mk_loc($loc($1)).trim_last_char() }
      Labelled(binder~, ty = $2)
    }
  | POST_LABEL opt_annot "=" expr {
      let binder = Binder::{ name: $1, loc: mk_loc($loc($1)).trim_last_char() }
      Optional(binder~, ty = $2, default = $4)
    }
  | LIDENT "?" opt_annot "=" expr {
      let binder = Binder::{ name: $1, loc: mk_loc($loc($1)) }
      Optional(binder~, ty = $3, default = $5)
    }
  | LIDENT "?" opt_annot {
      let binder = Binder::{ name: $1, loc: mk_loc($loc($1)) }
      QuestionOptional(binder~, ty = $3)
    }
  ;

parameters -> List[Parameter]
  : delimited("(", list_commas(parameter), ")") { $1 }
  ;

type_parameters -> List[TypeVarBinder]
  : delimited("[", non_empty_list_commas(id(tvar_binder)), "]") { $1 }
  ;

%inline is_async -> Bool
  : "async" { true }
  |  { false }
  ;

optional_type_parameters -> List[TypeVarBinder]
  : option(type_parameters) {
    match $1 {
      None => @list.empty()
      Some(params) => params
    }
  }
  ;

optional_type_parameters_no_constraints -> List[TypeDeclBinder]
  : option(delimited("[", non_empty_list_commas(id(type_decl_binder)), "]")) {
    match $1 {
      None => @list.empty()
      Some(params) => params
    }
  }
  ;

%inline optional_type_arguments -> List[Type]
  : ioption(delimited("[", non_empty_list_commas(type_), "]")) {
    match $1 {
      None => @list.empty()
      Some(params) => params
    }
  }
  ;

fun_binder -> (TypeName?, Binder)
  : type_name "::" LIDENT {
    let binder = Binder::{ name: $3, loc: mk_loc($loc($3)) }
    (Some($1), binder)
  }
  | binder { (None, $1) }
  ;

fun_header -> FunDecl
  : attributes visibility is_async fun_header_generic option(parameters) func_return_type {
    let ((type_name, f), has_error, quants) = $4
    let (return_type, error_type) = $6
    FunDecl::{
      type_name,
      name: f,
      has_error,
      is_async : $3,
      quantifiers: quants,
      decl_params: $5,
      params_loc: mk_loc($loc($5)),
      return_type,
      error_type,
      vis: $2,
      doc: DocString::empty(),
      attrs: $1,
    }
  }
  ;

fun_header_generic -> ((TypeName?, Binder), Location?, List[TypeVarBinder])
  : "fn" type_parameters fun_binder optional_bang { ($3, $4, $2) }
  | "fn" fun_binder optional_bang optional_type_parameters { ($2, $3, $4) }
  ;

local_type_decl -> LocalTypeDecl
  : "struct" UIDENT "{" list_semis(record_decl_field) "}" deriving_directive_list {
    LocalTypeDecl::{
      tycon : $2,
      tycon_loc : mk_loc($loc($2)),
      components: Record($4),
      deriving: $6
    }
  }
  | "struct" UIDENT "(" non_empty_list_commas(type_) ")" deriving_directive_list {
    LocalTypeDecl::{
      tycon : $2,
      tycon_loc : mk_loc($loc($2)),
      components: TupleStruct($4),
      deriving: $6
    }
  }
  | "enum" UIDENT "{" list_semis(enum_constructor) "}" deriving_directive_list {
    LocalTypeDecl::{
      tycon : $2,
      tycon_loc : mk_loc($loc($2)),
      components: Variant($4),
      deriving: $6
    }
  }
  | "type" UIDENT type_ deriving_directive_list {
    LocalTypeDecl::{
      tycon : $2,
      tycon_loc : mk_loc($loc($2)),
      components: Newtype($3),
      deriving: $4
    }
  }
  ;

extern_fun_header -> (StringLiteral, FunDecl)
  : attributes visibility "extern" STRING "fn" fun_binder optional_bang optional_type_parameters option(parameters) func_return_type {
    let (type_name, f) = $6
    let (return_type, error_type) = $10
    let fn_decl = FunDecl::{
      type_name,
      name: f,
      has_error : $7,
      is_async : false,
      quantifiers: $8,
      decl_params: $9,
      params_loc: mk_loc($loc($9)),
      return_type,
      error_type,
      vis: $2,
      doc: DocString::empty(),
      attrs: $1,
    }
    ($4, fn_decl)
  }
  ;

block_expr -> Expr
  : "{" list_semis_rev(statement) "}" {
    Statement::compact_rev($2, loc = mk_loc($sloc))
  }
  ;

local_types_and_stmts -> (List[LocalTypeDecl], Expr)
  : local_type_decl { (@list.singleton($1), Expr::Unit(loc = mk_loc($sloc), faked = true)) }
  | list_semis_rev(statement) { (@list.empty(), Statement::compact_rev($1, loc = mk_loc($sloc))) }
  | local_type_decl SEMI local_types_and_stmts { ($3.0.add($1), $3.1) }
  ;

block_expr_with_local_types -> (List[LocalTypeDecl], Expr)
  : "{" local_types_and_stmts "}" { $2 }
  ;

impl_body -> DeclBody
  : block_expr_with_local_types {
    let (local_types, expr) = $1
    DeclBody(local_types~, expr~)
  }
  | "=" STRING { DeclStubs(Embedded(language = None, code = CodeString($2))) }
  ;

expression -> Expr
  : expr EOF { $1 }
  ;

val_header -> (List[Attribute], Bool, Visibility, Binder, Type?)
  : attributes visibility "let" binder opt_annot { ($1, false, $2, $4, $5) }
  | attributes visibility "const" UIDENT opt_annot { ($1, true, $2, Binder::{ name : $4, loc : mk_loc($loc($4)) }, $5) }
  ;

structure -> List[Impl]
  : list_semis(structure_item) EOF { $1 }
  ;

structure_item -> Impl
  : type_header deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc, params) = $1
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params,
        components: Abstract,
        type_vis,
        doc : DocString::empty(),
        deriving: $2,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | attributes visibility "extern" "type" UIDENT optional_type_parameters_no_constraints deriving_directive_list {
    TopTypeDef(
      TypeDecl::{
        tycon : $5,
        tycon_loc : mk_loc($loc($5)),
        params : $6,
        components: Extern,
        type_vis : $2,
        doc : DocString::empty(),
        deriving: $7,
        loc : mk_loc($sloc),
        attrs : $1
      }
    )
  }
  | type_header type_ deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc, params) = $1
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params,
        components: Newtype($2),
        type_vis,
        doc : DocString::empty(),
        deriving: $3,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | suberror_header option(type_) deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc) = $1
    let exception_decl : ExceptionDecl = match $2 {
      None => NoPayload
      Some(ty) => SinglePayload(ty)
    }
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params: @list.empty(),
        components: Error(exception_decl),
        type_vis,
        doc : DocString::empty(),
        deriving: $3,
        loc : mk_loc($sloc),
        attrs
      }
    )

  }
  | suberror_header "{" list_semis(enum_constructor) "}" deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc) = $1
    let exception_decl : ExceptionDecl = EnumPayload($3)
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params: @list.empty(),
        components: Error(exception_decl),
        type_vis,
        doc : DocString::empty(),
        deriving: $5,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | struct_header "{" list_semis(record_decl_field) "}" deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc, params) = $1
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params,
        components: Record($3),
        type_vis,
        doc : DocString::empty(),
        deriving: $5,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | struct_header "(" non_empty_list_commas(type_) ")" deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc, params) = $1
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params,
        components: TupleStruct($3),
        type_vis,
        doc : DocString::empty(),
        deriving: $5,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | enum_header "{" list_semis(enum_constructor) "}" deriving_directive_list {
    let (attrs, type_vis, tycon, tycon_loc, params) = $1
    TopTypeDef(
      TypeDecl::{
        tycon,
        tycon_loc,
        params,
        components: Variant($3),
        type_vis,
        doc : DocString::empty(),
        deriving: $5,
        loc : mk_loc($sloc),
        attrs
      }
    )
  }
  | val_header "=" expr {
    let (attrs, is_constant, vis, binder, ty) = $1
    TopLetDef(
      binder~,
      ty~,
      expr = $3,
      vis~,
      is_constant~,
      loc = mk_loc($sloc),
      attrs~,
      doc = DocString::empty()
    )
  }
  | fun_header "=" STRING STRING {
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = $1,
      decl_body = DeclStubs(Import(module_name = $3, func_name = $4))
    )
  }
  | fun_header "=" STRING {
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = $1,
      decl_body = DeclStubs(Embedded(language = None, code = CodeString($3)))
    )
  }
  | fun_header "=" non_empty_list(MULTILINE_STRING) {
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = $1,
      decl_body = DeclStubs(Embedded(language = None, code = CodeMultilineString($3)))
    )
  }
  | extern_fun_header "=" STRING {
    let (language, decl) = $1
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = decl,
      decl_body = DeclStubs(Embedded(language = Some(language), code = CodeString($3)))
    )
  }
  | extern_fun_header "=" non_empty_list(MULTILINE_STRING) {
    let (language, decl) = $1
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = decl,
      decl_body = DeclStubs(Embedded(language = Some(language), code = CodeMultilineString($3)))
    )
  }
  | fun_header block_expr_with_local_types {
    let (local_types, expr) = $2
    TopFuncDef(
      loc = mk_loc($sloc),
      fun_decl = $1,
      decl_body = DeclBody(local_types~, expr~)
    )
  }
  | attributes visibility "fnalias" func_alias_targets {
    let (pkg, type_name, is_list, targets) = $4
    TopFuncAlias(
      pkg~,
      type_name~,
      targets~,
      vis = $2,
      attrs = $1,
      is_list~,
      doc = DocString::empty(),
      loc = mk_loc($sloc)
    )
  }
  | attributes visibility "trait" UIDENT option(preceded(COLON, separated_nonempty_list(PLUS, tvar_constraint))) "{" list_semis(trait_method_decl) "}" {
    let name = Binder::{ name: $4, loc: mk_loc($loc($4)) }
    let supers = match $5 {
      None => @list.empty()
      Some(supers) => supers
    }
    TopTrait(
      TraitDecl::{
        name,
        supers,
        methods: $7,
        vis: $2,
        loc: mk_loc($sloc),
        attrs: $1,
        doc : DocString::empty()
      }
    )
  }
  | attributes visibility "typealias" batch_type_alias_targets {
    let (is_list, pkg, targets) = $4
    TopBatchTypeAlias(
      pkg~,
      targets~,
      vis = $2,
      attrs = $1,
      is_list~,
      doc = DocString::empty(),
      loc = mk_loc($sloc)
    )
  }
  | attributes visibility "typealias" type_ "as" UIDENT optional_type_parameters_no_constraints {
    TopTypeDef(
      TypeDecl::{
        tycon : $6,
        tycon_loc : mk_loc($loc($6)),
        params : $7,
        components: Alias($4),
        type_vis : $2,
        doc : DocString::empty(),
        deriving: @list.empty(),
        loc : mk_loc($sloc),
        attrs : $1
      }
    )
  }
  | attributes visibility "traitalias" batch_type_alias_targets {
    let (is_list, pkg, targets) = $4
    TopBatchTraitAlias(
      pkg~,
      targets~,
      vis = $2,
      attrs = $1,
      is_list~,
      doc = DocString::empty(),
      loc = mk_loc($sloc)
    )
  }
  | attributes "test" option(loced_string) option(parameters) block_expr_with_local_types {
    let (local_types, expr) = $5
    TopTest(
      expr~,
      name = $3,
      params = $4,
      local_types~,
      loc = mk_loc($sloc),
      attrs = $1,
      doc = DocString::empty()
    )
  }
  | attributes visibility "impl" optional_type_parameters type_name "for" type_ "with" binder optional_bang parameters func_return_type impl_body {
    let (ret_ty, err_ty) = $12
    TopImpl(
      self_ty = Some($7),
      trait_ = $5,
      method_name = $9,
      has_error = $10,
      quantifiers = $4,
      params = $11,
      ret_ty~,
      err_ty~,
      body = $13,
      vis = $2,
      loc = mk_loc($sloc),
      attrs = $1,
      doc = DocString::empty()
    )
  }
  | attributes visibility "impl" optional_type_parameters type_name "with" binder optional_bang parameters func_return_type impl_body {
    let (ret_ty, err_ty) = $10
    TopImpl(
      self_ty = None,
      trait_ = $5,
      method_name = $7,
      has_error = $8,
      quantifiers = $4,
      params = $9,
      ret_ty~,
      err_ty~,
      body = $11,
      vis = $2,
      loc = mk_loc($sloc),
      attrs = $1,
      doc = DocString::empty()
    )
  }
  | attributes visibility "impl" optional_type_parameters type_name "for" type_ {
    TopImplRelation(
      self_ty = $7,
      trait_ = $5,
      quantifiers = $4,
      vis = $2,
      attrs = $1,
      loc = mk_loc($sloc),
      doc = DocString::empty()
    )
  }
  | attributes visibility "enumview" optional_type_parameters UIDENT "{" list_semis(enum_constructor) "}" "for" type_ "with" binder parameters block_expr {
    TopView(
      quantifiers = $4,
      source_ty = $10,
      view_type_name = $5,
      view_type_loc = mk_loc($loc($5)),
      view_func_name = $12,
      parameters = $13,
      params_loc = mk_loc($loc($13)),
      view_constrs = $7,
      body = $14,
      vis = $2,
      loc = mk_loc($sloc),
      attrs = $1,
      doc = DocString::empty()
    )
  }
  ;

%inline attributes -> List[Attribute]
  :  { @list.empty() }
  | non_empty_list(attribute) { $1 }
  ;

%inline attribute -> Attribute
  : ATTRIBUTE { make_attribute(loc=mk_loc($sloc), id = $1.0, dot_id = $1.1, raw_payload = $1.2) }
  ;

%inline visibility -> Visibility
  :  { Default }
  | "priv" { Priv(loc = mk_loc($sloc)) }
  | "pub" pub_attr { Pub(loc = mk_loc($sloc), attr = $2) }
  ;

pub_attr -> String?
  :  { None }
  | "(" "readonly" ")" { Some("readonly") }
  | "(" LIDENT ")" { Some($2) }
  ;

type_header -> (List[Attribute], Visibility, String, Location, List[TypeDeclBinder])
  : attributes visibility "type" UIDENT optional_type_parameters_no_constraints { 
    ($1, $2, $4, mk_loc($loc($4)), $5) 
  }
  ;

suberror_header -> (List[Attribute], Visibility, String, Location)
  : attributes visibility "suberror" UIDENT { ($1, $2, $4, mk_loc($loc($4))) }
  ;

struct_header -> (List[Attribute], Visibility, String, Location, List[TypeDeclBinder])
  : attributes visibility "struct" UIDENT optional_type_parameters_no_constraints { 
    ($1, $2, $4, mk_loc($loc($4)), $5) 
  }
  ;

enum_header -> (List[Attribute], Visibility, String, Location, List[TypeDeclBinder])
  : attributes visibility "enum" UIDENT optional_type_parameters_no_constraints { 
    ($1, $2, $4, mk_loc($loc($4)), $5) 
  }
  ;

batch_type_alias_targets -> (Bool, Label?, List[AliasTarget])
  : PACKAGE_NAME batch_type_alias_target(DOT_UIDENT) { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (false, Some(pkg), @list.singleton($2))
  }
  | PACKAGE_NAME ".(" non_empty_list_commas(batch_type_alias_target(UIDENT)) ")" { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (true, Some(pkg), $3)
  }
  | batch_type_alias_target(UIDENT) { (false, None, @list.singleton($1)) }
  ;

batch_type_alias_target(UIDENT_MAYBE_DOT) -> AliasTarget
  : UIDENT_MAYBE_DOT { 
    let binder = Binder::{ name: $1, loc: mk_loc($loc($1)) }
    AliasTarget::{ binder, target: None }
  }
  | UIDENT_MAYBE_DOT "as" UIDENT { 
    let target = Label::{ name: $1, loc: mk_loc($loc($1)) }
    let binder = Binder::{ name: $3, loc: mk_loc($loc($3)) }
    AliasTarget::{ binder, target: Some(target) }
  }
  ;

func_alias_targets -> (Label?, Label?, Bool, List[AliasTarget])
  : ioption(func_alias_type_name(LIDENT, UIDENT)) func_alias_target(LIDENT) { 
    (None, $1, false, @list.singleton($2))
  }
  | PACKAGE_NAME func_alias_target(DOT_LIDENT) { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (Some(pkg), None, false, @list.singleton($2))
  }
  | PACKAGE_NAME func_alias_type_name(DOT_LIDENT, DOT_UIDENT) func_alias_target(LIDENT) { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (Some(pkg), Some($2), false, @list.singleton($3))
  }
  | option(func_alias_type_name(LIDENT, UIDENT)) "(" non_empty_list_commas(func_alias_target(LIDENT)) ")" { 
    (None, $1, true, $3)
  }
  | PACKAGE_NAME ".(" non_empty_list_commas(func_alias_target(LIDENT)) ")" { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (Some(pkg), None, true, $3)
  }
  | PACKAGE_NAME func_alias_type_name(DOT_LIDENT, DOT_UIDENT) "(" non_empty_list_commas(func_alias_target(LIDENT)) ")" { 
    let pkg = Label::{ name: $1, loc: mk_loc($loc($1)) }
    (Some(pkg), Some($2), true, $4)
  }
  ;

func_alias_type_name(LIDENT_MAYBE_DOT, UIDENT_MAYBE_DOT) -> Label
  : LIDENT_MAYBE_DOT "::" { Label::{ name: $1, loc: mk_loc($loc($1)) } }
  | UIDENT_MAYBE_DOT "::" { Label::{ name: $1, loc: mk_loc($loc($1)) } }
  ;

func_alias_target(LIDENT_MAYBE_DOT) -> AliasTarget
  : LIDENT_MAYBE_DOT option(preceded("as", binder)) { 
    match $2 {
      None => {
        let binder = Binder::{ name: $1, loc: mk_loc($loc($1)) }
        AliasTarget::{ binder, target: None }
      }
      Some(binder) => {
        let target = Label::{ name: $1, loc: mk_loc($loc($1)) }
        AliasTarget::{ binder, target: Some(target) }
      }
    }
  }
  ;

deriving_directive -> DerivingDirective
  : type_name { DerivingDirective::{ type_name: $1, args: @list.empty(), loc: mk_loc($sloc) } }
  | type_name "(" list_commas(argument) ")" { DerivingDirective::{ type_name: $1, args: $3, loc: mk_loc($sloc) } }
  ;

deriving_directive_list -> List[DerivingDirective]
  :  { @list.empty() }
  | "derive" "(" list_commas(deriving_directive) ")" { $3 }
  ;

trait_method_decl -> TraitMethodDecl
  : attributes is_async binder optional_bang optional_type_parameters "(" list_commas(trait_method_param) ")" func_return_type option(preceded("=", wildcard)) { 
    let (return_type, error_type) = $9
    TraitMethodDecl::{
      name: $3,
      has_error: $4,
      is_async: $2,
      quantifiers: $5,
      params: $7,
      return_type,
      error_type,
      has_default: $10,
      attrs: $1,
      loc: mk_loc($sloc)
    }
  }
  ;

wildcard -> Location
  : "_" { mk_loc($sloc) }
  ;

trait_method_param -> Parameter
  : type_ { DiscardPositional(ty = Some($1), loc = mk_loc($sloc)) }
  | binder ":" type_ { Positional(binder = $1, ty = Some($3)) }
  | POST_LABEL ":" type_ { 
    let binder = Binder::{ name: $1, loc: mk_loc($loc($1)).trim_last_char() }
    Labelled(binder~, ty = Some($3))
  }
  ;

qual_ident -> LongIdent
  : LIDENT { Ident(name = $1) }
  | PACKAGE_NAME DOT_LIDENT { Dot(pkg = $1, id = $2) }
  ;

qual_ident_simple_expr -> LongIdent
  : LIDENT %prec prec_apply_non_ident_fn { Ident(name = $1) }
  | PACKAGE_NAME DOT_LIDENT { Dot(pkg = $1, id = $2) }
  ;

%inline qual_ident_ty_inline -> LongIdent
  : UIDENT { LongIdent::Ident(name = $1) }
  | PACKAGE_NAME DOT_LIDENT { LongIdent::Dot(pkg = $1, id = $2) }
  | PACKAGE_NAME DOT_UIDENT { LongIdent::Dot(pkg = $1, id = $2) }
  ;

qual_ident_ty -> LongIdent
  : qual_ident_ty_inline { $1 }
  ;

%inline semi_expr_semi_opt -> (Expr, Bool)
  : none_empty_list_semis_rev_with_trailing_info(statement) { 
    let (ls, trailing) = $1
    (Statement::compact_rev(ls, loc = mk_loc($sloc)), trailing)
  }
  ;

optional_bang -> Location? 
  : "!" { Some(mk_loc($sloc)) }
  |  { None }
  ;

fn_header -> (Binder, Location?)
  : "fn" binder optional_bang "{" { ($2, $3) }
  ;

fn_header_no_binder -> Location?
  : "fn" optional_bang "{" { $2 }
  ;

letand_func -> Func
  : arrow_fn_expr { $1 }
  | anony_fn { $1 }
  ;

and_func -> (Binder, Type?, Func)
  : "and" binder opt_annot "=" letand_func { ($2, $3, $5) }
  ;

statement -> Statement
  : "let" pattern opt_annot "=" expr { 
    let pat = match $3 {
      None => $2
      Some(ty) => Pattern::Constraint(pat = $2, ty~, loc = mk_loc($sloc))
    }
    StmtLet(pat~, expr = $5, loc = mk_loc($sloc))
  }
  | "letrec" binder opt_annot "=" letand_func list(and_func) {
    let bindings = $6.add(($2, $3, $5))
    StmtLetand(bindings~, loc = mk_loc($sloc))
  }
  | "let" "mut" binder opt_annot "=" expr { 
    StmtLetmut(binder = $3, ty_opt = $4, expr = $6, loc = mk_loc($sloc))
  }
  | is_async "fn" binder optional_bang parameters func_return_type block_expr { 
    let (return_type, error_type) = $6
    let func = Func::Lambda(
      parameters = $5,
      params_loc = mk_loc($loc($5)),
      body = $7,
      return_type~,
      error_type~,
      kind = Lambda,
      has_error = $4,
      is_async = $1,
      loc = mk_loc($sloc)
    )
    StmtFunc(binder = $3, func~, loc = mk_loc($sloc))
  }
  | is_async fn_header list_semis(multi_pattern_case) "}" { 
    let (binder, has_error) = $2
    let func = Func::Match(
      cases = $3,
      has_error~,
      is_async = $1,
      fn_loc = mk_loc($loc($2)),
      loc = mk_loc($sloc)
    )
    StmtFunc(binder~, func~, loc = mk_loc($sloc))
  }
  | guard_statement { $1 }
  | "defer" pipe_expr { StmtDefer(expr = $2, loc = mk_loc($sloc)) }
  | expr_statement { StmtExpr($1) }
  ;

guard_statement -> Statement
  : "guard" infix_expr { StmtGuard(cond = $2, otherwise = None, loc = mk_loc($sloc)) }
  | "guard" infix_expr "else" block_expr { StmtGuard(cond = $2, otherwise = Some($4), loc = mk_loc($sloc)) }
  ;

%inline assignment_expr -> Expr
  : left_value "=" expr { 
    let loc = mk_loc($sloc)
    match $1 {
      Var(var_) => Assign(var_~, expr=$3, augmented_by=None, loc~)
      Field(record, accessor) => Mutate(record~, accessor~, field=$3, augmented_by=None, loc~)
      Array(array, index) => ArraySet(array~, index~, value=$3, loc~)
    }
  }
  ;

%inline augmented_assignment_expr -> Expr
  : left_value assignop expr { 
    let loc = mk_loc($sloc)
    match $1 {
      Var(var_) => Assign(var_~, expr=$3, augmented_by=Some($2), loc~)
      Field(record, accessor) => Mutate(record~, accessor~, field=$3, augmented_by=Some($2), loc~)
      Array(array, index) => ArrayAugmentedSet(op=$2, array~, index~, value=$3, loc~)
    }
  }
  ;

expr_statement_no_break_continue_return -> Expr
  : "raise" expr { Raise(err_value = $2, loc = mk_loc($sloc)) }
  | "..." { Hole(loc = mk_loc($sloc), kind = Todo) }
  | augmented_assignment_expr { $1 }
  | assignment_expr { $1 }
  | expr { $1 }
  ;

expr_statement -> Expr
  : "break" POST_LABEL option(expr) { 
    let label = Label::{ name: $2, loc: mk_loc($loc($2)) }
    Break(arg = $3, label = Some(label), loc = mk_loc($sloc))
  }
  | "break" option(expr) { Break(arg = $2, label = None, loc = mk_loc($sloc)) }
  | "continue" POST_LABEL list_commas_no_trailing(expr) { 
    let label = Label::{ name: $2, loc: mk_loc($loc($2)) }
    Continue(args = $3, label = Some(label), loc = mk_loc($sloc))
  }
  | "continue" list_commas_no_trailing(expr) { Continue(args = $2, label = None, loc = mk_loc($sloc)) }
  | "return" option(expr) { Return(return_value = $2, loc = mk_loc($sloc)) }
  | expr_statement_no_break_continue_return { $1 }
  ;

loop_label_colon -> Label?
  : POST_LABEL ":" { Some(Label::{ name : $1, loc : mk_loc($sloc) }) }
  |  { None}
  ;

while_expr -> Expr
  : loop_label_colon "while" infix_expr block_expr optional_else { 
    While(
      loop_cond = $3,
      loop_body = $4,
      while_else = $5,
      label = $1,
      loc = mk_loc($sloc)
    )
  }
  ;

single_pattern_case -> Case
  : pattern option(preceded("if", infix_expr)) "=>" expr_statement { 
    Case::{ pattern : $1, guard_ : $2, body : $4 }
  }
  | "..." { 
    Case::{ 
      pattern : Pattern::Any(loc = mk_loc($sloc)), 
      guard_ : None, 
      body : Hole(loc = mk_loc($sloc), kind = Todo) 
    }
  }
  ;

single_pattern_cases -> List[Case]
  : list_semis(single_pattern_case) { $1 }
  ;

multi_pattern_case -> MultiArgCase
  : non_empty_list_commas(pattern) option(preceded("if", infix_expr)) "=>" expr_statement { 
    MultiArgCase::{ patterns : $1, guard_ : $2, body : $4 }
  }
  ;

catch_keyword -> (Bool, Location)
  : "catch" "{" { (false, mk_loc($sloc)) }
  | "catch" "!" "{" { (true, mk_loc($sloc)) }
  ;

%inline else_keyword -> Location
  : "noraise" "{" { mk_loc($sloc) }
  ;

try_expr -> Expr
  : "try" pipe_expr catch_keyword single_pattern_cases "}" { 
    let (catch_all, catch_loc) = $3
    Try(
      body = $2,
      catch_ = $4,
      catch_all~,
      try_else = None,
      has_try = true,
      try_loc = mk_loc($loc($1)),
      catch_loc~,
      else_loc = @basic.Location::{ start: @basic.Position::{ fname: "", lnum: 0, bol: 0, cnum: 0 }, end: @basic.Position::{ fname: "", lnum: 0, bol: 0, cnum: 0 } },
      loc = mk_loc($sloc)
    )
  }
  | "try" pipe_expr catch_keyword single_pattern_cases "}" else_keyword single_pattern_cases "}" { 
    let (catch_all, catch_loc) = $3
    let else_loc = $6
    Try(
      body = $2,
      catch_ = $4,
      catch_all~,
      try_else = Some($7),
      has_try = true,
      try_loc = mk_loc($loc($1)),
      catch_loc~,
      else_loc~,
      loc = mk_loc($sloc)
    )
  }
  | "try?" pipe_expr { 
    TryOperator(body = $2, kind = Question, try_loc = mk_loc($loc($1)), loc = mk_loc($sloc))
  }
  | "try!" pipe_expr {
    TryOperator(body = $2, kind = Exclamation, try_loc = mk_loc($loc($1)), loc = mk_loc($sloc))
  }
  ;

if_expr -> Expr
  : "if" infix_expr block_expr "else" block_expr { 
    If(cond = $2, ifso = $3, ifnot = Some($5), loc = mk_loc($sloc))
  }
  | "if" infix_expr block_expr "else" if_expr { 
    If(cond = $2, ifso = $3, ifnot = Some($5), loc = mk_loc($sloc))
  }
  | "if" infix_expr block_expr { 
    If(cond = $2, ifso = $3, ifnot = None, loc = mk_loc($sloc))
  }
  ;

match_header -> (Expr, Label?)
  : "match" infix_expr "{" { ($2, None) }
  | "match" infix_expr "using" label "{" { ($2, Some($4)) }
  ;

match_expr -> Expr
  : match_header non_empty_list_semis(single_pattern_case) "}" { 
    let (expr, using_label) = $1
    Match(
      expr~,
      cases = $2,
      match_loc = mk_loc($loc($1)),
      using_ = using_label,
      loc = mk_loc($sloc)
    )
  }
  | match_header "}" { 
    let (expr, using_label) = $1
    Match(
      expr~,
      cases = @list.empty(),
      match_loc = mk_loc($loc($1)),
      using_ = using_label,
      loc = mk_loc($sloc)
    )
  }
  ;

%inline loop_header -> List[Expr]
  : "loop" non_empty_list_commas_no_trailing(expr) "{" { $2 }
  ;

loop_expr -> Expr
  : loop_label_colon loop_header list_semis(multi_pattern_case) "}" { 
    Loop(
      args = $2,
      body = $3,
      label = $1,
      loop_loc = mk_loc($loc($2)),
      loc = mk_loc($sloc)
    )
  }
  ;

for_binders -> List[(Binder, Expr)]
  : list_commas_no_trailing(separated_pair(binder, "=", expr)) { $1 }
  ;

optional_else -> Expr?
  : "else" block_expr { Some($2) }
  |  { None }
  ;

for_expr -> Expr
  : loop_label_colon "for" for_binders SEMI option(infix_expr) SEMI list_commas_no_trailing(separated_pair(binder, "=", expr)) block_expr optional_else {
    For(
      binders = $3,
      condition = $5,
      continue_block = $7,
      body = $8,
      for_else = $9,
      label = $1,
      loc = mk_loc($sloc)
    )
  }
  | loop_label_colon "for" for_binders block_expr optional_else {
    For(
      binders = $3,
      condition = None,
      continue_block = @list.empty(),
      body = $4,
      for_else = $5,
      label = $1,
      loc = mk_loc($sloc)
    )
  }
  ;

foreach_expr -> Expr
  : loop_label_colon "for" non_empty_list_commas(foreach_binder) "in" expr block_expr optional_else { 
    ForEach(
      binders = $3,
      expr = $5,
      body = $6,
      else_block = $7,
      label = $1,
      loc = mk_loc($sloc)
    )
  }
  ;

foreach_binder -> Binder?
  : binder { Some($1)}
  | "_" { None }
  ;

expr -> Expr
  : loop_expr { $1 }
  | for_expr { $1 }
  | foreach_expr { $1 }
  | while_expr { $1 }
  | try_expr { $1 }
  | if_expr { $1 }
  | match_expr { $1 }
  | simple_try_expr { $1 }
  | arrow_fn_expr { Function(func = $1, loc = mk_loc($sloc)) }
  ;

simple_try_expr -> Expr
  : pipe_expr catch_keyword single_pattern_cases "}" { 
    let (catch_all, catch_loc) = $2
    Try(
      body = $1,
      catch_ = $3,
      catch_all~,
      try_else = None,
      has_try = false,
      try_loc = mk_loc($loc($1)),
      catch_loc~,
      else_loc = Location::{ start: Position::{ fname: "", lnum: 0, bol: 0, cnum: 0 }, end: Position::{ fname: "", lnum: 0, bol: 0, cnum: 0 } },
      loc = mk_loc($sloc)
    )
  }
  | pipe_expr { $1 }
  ;

arrow_fn_expr -> Func
  : "(" arrow_fn_prefix "=>" expr_statement_no_break_continue_return { 
    make_arrow_fn($2, $4, loc = mk_loc($sloc))
  }
  | "(" ")" "=>" expr_statement_no_break_continue_return { 
    make_arrow_fn(@list.empty(), $4, loc = mk_loc($sloc))
  }
  | binder "=>" expr_statement_no_break_continue_return { 
    make_arrow_fn(@list.singleton((Named($1), None)), $3, loc = mk_loc($sloc))
  }
  | "_" "=>" expr_statement_no_break_continue_return { 
    make_arrow_fn(@list.singleton((Unnamed(mk_loc($loc($1))), None)), $3, loc = mk_loc($sloc))
  }
  ;

arrow_fn_prefix -> List[(ArrowFnParam, Type?)]
  : binder ioption(",") ")" { @list.singleton((Named($1), None)) }
  | "_" ioption(",") ")" { @list.singleton((Unnamed(mk_loc($loc($1))), None)) }
  | binder ":" type_ ioption(",") ")" { @list.singleton((Named($1), Some($3))) }
  | "_" ":" type_ ioption(",") ")" { @list.singleton((Unnamed(mk_loc($loc($1))), Some($3))) }
  | binder "," arrow_fn_prefix { $3.add((Named($1), None)) }
  | "_" "," arrow_fn_prefix { $3.add((Unnamed(mk_loc($loc($1))), None)) }
  | binder ":" type_ "," arrow_fn_prefix { $5.add((Named($1), Some($3))) }
  | "_" ":" type_ "," arrow_fn_prefix { $5.add((Unnamed(mk_loc($loc($1))), Some($3))) }
  ;

arrow_fn_prefix_no_constraint -> List[ArrowFnParam]
  : binder ioption(",") ")" { @list.singleton(Named($1)) }
  | "_" ioption(",") ")" { @list.singleton(Unnamed(mk_loc($loc($1)))) }
  | binder "," arrow_fn_prefix_no_constraint { $3.add(Named($1)) }
  | "_" "," arrow_fn_prefix_no_constraint { $3.add(Unnamed(mk_loc($loc($1)))) }
  ;

pipe_expr -> Expr
  : pipe_expr "|>" infix_expr { 
    Pipe(lhs = $1, rhs = $3, loc = mk_loc($sloc))
  }
  | infix_expr { $1 }
  ;

infix_expr -> Expr
  : infix_expr infixop infix_expr { 
    Infix(op = $2, lhs = $1, rhs = $3, loc = mk_loc($sloc))
  }
  | postfix_expr { $1 }
  ;

postfix_expr -> Expr
  : range_expr "as" type_name { 
    As(expr = $1, trait_ = $3, loc = mk_loc($sloc))
  }
  | range_expr "is" range_pattern { 
    Is(expr = $1, pat = $3, loc = mk_loc($sloc))
  }
  | range_expr { $1 }
  ;

range_expr -> Expr
  : prefix_expr "..<" prefix_expr { 
    Infix(
      op = Var::{ name: Ident(name = "..<"), loc: mk_loc($loc($2)) }, 
      lhs = $1, 
      rhs = $3, 
      loc = mk_loc($sloc)
    )
  }
  | prefix_expr "..=" prefix_expr { 
    Infix(
      op = Var::{ name: Ident(name = "..="), loc: mk_loc($loc($2)) }, 
      lhs = $1, 
      rhs = $3, 
      loc = mk_loc($sloc)
    )
  }
  | prefix_expr { $1 }
  ;

prefix_expr -> Expr
  : id(plus) prefix_expr { make_uplus(loc = mk_loc($sloc), $1, $2) }
  | id(minus) prefix_expr { make_uminus(loc = mk_loc($sloc), $1, $2) }
  | "!" prefix_expr { make_unot(loc = mk_loc($sloc), $2) }
  | simple_expr { $1 }
  ;

%inline plus -> String
  : PLUS { "+" }
  ;

%inline minus -> String
  : MINUS { "-" }
  ;

left_value -> LeftValue
  : var { Var($1) }
  | simple_expr accessor { Field($1, $2) }
  | simple_expr "[" expr "]" { Array($1, $3) }
  ;

constr -> Constructor
  : UIDENT { 
    Constructor::{
      name: ConstrName::{ name: $1, loc: mk_loc($loc($1)) },
      extra_info: NoExtraInfo,
      loc: mk_loc($sloc)
    }
  }
  | PACKAGE_NAME DOT_UIDENT { 
    Constructor::{
      name: ConstrName::{ name: $2, loc: mk_loc($loc($2)) },
      extra_info: Package($1),
      loc: mk_loc($sloc)
    }
  }
  | type_name "::" UIDENT { 
    Constructor::{
      name: ConstrName::{ name: $3, loc: mk_loc($loc($3)) },
      extra_info: TypeName($1),
      loc: mk_loc($sloc)
    }
  }
  ;

%inline apply_attr -> ApplyAttr
  :  { NoAttr }
  | "!" { Exclamation }
  | "?" { Question }
  ;

non_empty_tuple_elems -> List[Expr]
  : expr ioption(",") ")" { @list.singleton($1) }
  | expr "," non_empty_tuple_elems { $3.add($1) }
  ;

non_empty_tuple_elems_with_prefix -> List[Expr]
  : binder "," non_empty_tuple_elems_with_prefix { $3.add(@syntax.binder_to_expr($1)) }
  | "_" "," non_empty_tuple_elems_with_prefix { $3.add(Expr::Hole(loc = mk_loc($loc($1)), kind = Incomplete)) }
  | non_empty_tuple_elems { $1 }
  ;

tuple_expr -> Expr 
  : "(" arrow_fn_prefix_no_constraint { 
    let es = $2.map(@syntax.arrow_fn_param_to_expr)
    match es {
      @list.More(expr, tail=Empty) => {
        match expr {
          Constraint(..) => expr
          _ => Group(expr~, group = Paren, loc = mk_loc($sloc))
        }
      }
      _ => @syntax.make_tuple_expr(loc = mk_loc($sloc), es)
    }
  }
  | "(" non_empty_tuple_elems_with_prefix { 
    match $2 {
      More(expr, tail=Empty) => Group(expr~, group = Paren, loc = mk_loc($sloc))
      exprs => @syntax.make_tuple_expr(loc = mk_loc($sloc), exprs)
    }
  }
  | "(" binder ":" type_ ")" { Constraint(expr = @syntax.binder_to_expr($2), ty = $4, loc = mk_loc($sloc)) }
  | "(" "_" ":" type_ ")" { Constraint(expr = Hole(loc = mk_loc($loc($2)), kind = Incomplete), ty = $4, loc = mk_loc($sloc)) }
  | "(" expr ":" type_ ")" { Constraint(expr = $2, ty = $4, loc = mk_loc($sloc)) }
  | "(" ")" { Unit(loc = mk_loc($sloc), faked = false) }
  ;

anony_fn -> Func
  : is_async "fn" optional_bang parameters func_return_type block_expr { 
    let (return_type, error_type) = $5
    Lambda(
      parameters = $4,
      params_loc = mk_loc($loc($4)),
      body = $6,
      return_type~,
      error_type~,
      kind = Lambda,
      has_error = $3,
      is_async = $1,
      loc = mk_loc($sloc)
    )
  }
  | is_async fn_header_no_binder list_semis(multi_pattern_case) "}" { 
    Match(
      cases = $3,
      has_error = $2,
      is_async = $1,
      fn_loc = mk_loc($loc($2)),
      loc = mk_loc($sloc)
    )
  }
  ;

simple_expr -> Expr
  : "{" record_defn "}" { 
    let (fs, trailing) = $2
    @syntax.make_record_expr(loc = mk_loc($sloc), trailing~, None, fs)
  }
  | type_name COLONCOLON "{" list_commas_with_trailing_info(record_defn_single) "}" { 
    let (fs, trailing) = $4  
    let trailing_mark = if trailing { TrailingMark::Comma } else { TrailingMark::None }
    @syntax.make_record_expr(loc = mk_loc($sloc), trailing = trailing_mark, Some($1), fs)
  }
  | ioption(terminated(type_name, COLONCOLON)) "{" ".." expr "}" { 
    RecordUpdate(type_name = $1, record = $4, fields = @list.empty(), loc = mk_loc($sloc))
  }
  | ioption(terminated(type_name, COLONCOLON)) "{" ".." expr "," list_commas(record_defn_single) "}" { 
    RecordUpdate(type_name = $1, record = $4, fields = $6, loc = mk_loc($sloc))
  }
  | "{" semi_expr_semi_opt "}" { 
    let (expr, trailing) = $2
    match expr {
      Ident(id = { name: Ident(name~), loc }, ..) => {
        let label = Label::{ name, loc }
        let field = @syntax.make_field_def(loc = mk_loc($sloc), label, expr, true)
        let trailing_mark = if trailing { TrailingMark::Semi } else { TrailingMark::None }
        @syntax.make_record_expr(loc = mk_loc($sloc), trailing = trailing_mark, None, @list.singleton(field))
      }
      _ => Group(expr~, group = Brace, loc = mk_loc($sloc))
    }
  }
  | "{" list_commas(map_expr_elem) "}" { 
    Map(elems = $2, loc = mk_loc($sloc))
  }
  | anony_fn { Function(func = $1, loc = mk_loc($sloc)) }
  | atomic_expr { $1 }
  | "_" %prec prec_lower_than_arrow_fn { Hole(loc = mk_loc($sloc), kind = Incomplete) }
  | qual_ident_simple_expr { @syntax.make_ident_expr(loc = mk_loc($sloc), Var::{ name: $1, loc: mk_loc($sloc) }) }
  | constr { Constr(constr = $1, loc = mk_loc($sloc)) }
  | LIDENT "?" "(" list_commas(argument) ")" { 
    let func = @syntax.make_ident_expr(
      loc = mk_loc($loc($1)), 
      Var::{ name: Ident(name = $1), loc: mk_loc($loc($1)) }
    )
    Apply(func~, args = $4, attr = Question, loc = mk_loc($sloc))
  }
  | simple_expr apply_attr "(" list_commas(argument) ")" { 
    Apply(func = $1, args = $4, attr = $2, loc = mk_loc($sloc))
  }
  | simple_expr "[" expr "]" { 
    ArrayGet(array = $1, index = $3, loc = mk_loc($sloc))
  }
  | simple_expr "[" option(expr) ":" option(expr) "]" { 
    ArrayGetSlice(
      array = $1,
      start_index = $3,
      end_index = $5,
      index_loc = mk_loc(($loc($2).0, $loc($6).1)),
      loc = mk_loc($sloc)
    )
  }
  | simple_expr DOT_LIDENT apply_attr "(" list_commas(argument) ")" { 
    let method_name = Label::{ name: $2, loc: mk_loc($loc($2)) }
    DotApply(
      self = $1,
      method_name~,
      args = $5,
      return_self = false,
      attr = $3,
      loc = mk_loc($sloc)
    )
  }
  | simple_expr ".." LIDENT apply_attr "(" list_commas(argument) ")" { 
    let method_name = Label::{ name: $3, loc: mk_loc($loc($3)) }
    DotApply(
      self = $1,
      method_name~,
      args = $6,
      return_self = true,
      attr = $4,
      loc = mk_loc($sloc)
    )
  }
  | simple_expr accessor %prec prec_field { 
    Field(record = $1, accessor = $2, loc = mk_loc($sloc))
  }
  | type_name "::" LIDENT { 
    let method_name = Label::{ name: $3, loc: mk_loc($loc($3)) }
    Method(type_name = $1, method_name~, loc = mk_loc($sloc))
  }
  | "[" list_commas(spreadable_elem) "]" { @syntax.make_array_expr(loc = mk_loc($sloc), $2) }
  | tuple_expr { $1 }
  ;

%inline label -> Label
  : LIDENT { Label::{ name: $1, loc: mk_loc($sloc) } }
  ;

%inline accessor -> Accessor
  : DOT_LIDENT { 
    if $1 == "_" {
      Newtype(loc = mk_loc($loc($1)))
    } else {
      Label(Label::{ name: $1, loc: mk_loc($sloc) })
    }
  }
  | DOT_INT { Index(tuple_index = $1, loc = mk_loc($sloc)) }
  ;

%inline binder -> Binder
  : LIDENT { Binder::{ name: $1, loc: mk_loc($sloc) } }
  ;

tvar_binder -> TypeVarBinder
  : UIDENT { 
    TypeVarBinder::{ name: $1, constraints: @list.empty(), name_loc: mk_loc($loc($1)) }
  }
  | UIDENT COLON separated_nonempty_list(PLUS, tvar_constraint) { 
    TypeVarBinder::{ name: $1, constraints: $3, name_loc: mk_loc($loc($1)) }
  }
  ;

type_decl_binder -> TypeDeclBinder
  : UIDENT { TypeDeclBinder::{ name: Some($1), loc: mk_loc($sloc) } }
  | "_" { TypeDeclBinder::{ name: None, loc: mk_loc($sloc) } }
  ;

tvar_constraint -> TypeVarConstraint
  : qual_ident_ty { TypeVarConstraint::{ trait_: $1, loc: mk_loc($sloc) } }
  ;

%inline var -> Var
  : qual_ident { Var::{ name: $1, loc: mk_loc($sloc) } }
  ;

type_name -> TypeName
  : qual_ident_ty { TypeName::{ name: $1, is_object: false, loc: mk_loc($sloc) } }
  | "&" qual_ident_ty { TypeName::{ name: $2, is_object: true, loc: mk_loc($sloc) } }
  ;

multiline_string -> MultilineStringElem
  : MULTILINE_STRING { String($1) }
  | MULTILINE_INTERP { 
    Interp(make_interps($1))
  }
  ;

atomic_expr -> Expr
  : simple_constant { make_constant_expr(loc = mk_loc($sloc), $1) }
  | non_empty_list(multiline_string) { 
    MultilineString(elems = $1, loc = mk_loc($sloc))
  }
  | INTERP { make_interp_expr(loc = mk_loc($sloc), $1) }
  ;

simple_constant -> Constant
  : TRUE { Bool(true) }
  | FALSE { Bool(false) }
  | BYTE { Byte($1) }
  | BYTES { Bytes($1) }
  | CHAR { Char($1) }
  | INT { make_int($1) }
  | DOUBLE { make_double($1) }
  | FLOAT { make_float($1) }
  | STRING { String($1) }
  ;

map_syntax_key -> Constant
  : simple_constant { $1 }
  | MINUS INT { make_int("-" + $2) }
  | MINUS DOUBLE { make_double("-" + $2) }
  | MINUS FLOAT { make_float("-" + $2) }
  ;

%inline loced_string -> (StringLiteral, Location)
  : STRING { ($1, mk_loc($sloc)) }
  ;

%inline assignop -> Var
  : AUGMENTED_ASSIGNMENT { Var::{ name: Ident(name = $1), loc: mk_loc($sloc) } }
  ;

%inline infixop -> Var
  : INFIX4 { Var::{ name: Ident(name = $1), loc: mk_loc($sloc) } }
  | INFIX3 { Var::{ name: Ident(name = $1), loc: mk_loc($sloc) } }
  | INFIX2 { Var::{ name: Ident(name = $1), loc: mk_loc($sloc) } }
  | INFIX1 { Var::{ name: Ident(name = $1), loc: mk_loc($sloc) } }
  | PLUS { Var::{ name: Ident(name = "+"), loc: mk_loc($sloc) } }
  | MINUS { Var::{ name: Ident(name = "-"), loc: mk_loc($sloc) } }
  | AMPER { Var::{ name: Ident(name = "&"), loc: mk_loc($sloc) } }
  | CARET { Var::{ name: Ident(name = "^"), loc: mk_loc($sloc) } }
  | BAR { Var::{ name: Ident(name = "|"), loc: mk_loc($sloc) } }
  | AMPERAMPER { Var::{ name: Ident(name = "&&"), loc: mk_loc($sloc) } }
  | BARBAR { Var::{ name: Ident(name = "||"), loc: mk_loc($sloc) } }
  ;

optional_question -> Location?
  : "?" { Some(mk_loc($sloc)) }
  |  { None }
  ;

argument -> Argument
  : label optional_question "=" expr { 
    let arg_kind : ArgumentKind = match $2 {
      Some(question_loc) => LabelledOption(label = $1, question_loc~)
      None => Labelled($1)
    }
    Argument::{ value: $4, kind: arg_kind }
  }
  | expr { Argument::{ value: $1, kind: Positional } }
  | POST_LABEL { 
    let label = Label::{ name: $1, loc: mk_loc($loc($1)) }
    let arg_value = @syntax.make_ident_expr(loc = mk_loc($loc($1)), Var::{ name: Ident(name = $1), loc: mk_loc($loc($1)) })
    Argument::{ value: arg_value, kind: LabelledPun(label) }
  }
  | POST_LABEL "=" expr {
    let label = Label::{ name: $1, loc: mk_loc($loc($1)) }
    let arg_value = $3
    Argument::{ value: arg_value, kind: Labelled(label) }
  }
  | LIDENT "?" { 
    let loc = mk_loc($loc($1))
    let label = Label::{ name: $1, loc }
    let arg_value = @syntax.make_ident_expr(loc~, Var::{ name: Ident(name = $1), loc })
    Argument::{ value: arg_value, kind: LabelledOptionPun(label~, question_loc = mk_loc($loc($2))) }
  }
  ;

spreadable_elem -> SpreadableElem
  : expr { Regular($1) }
  | ".." expr { Spread(expr = $2, loc = mk_loc($sloc)) }
  ;

map_expr_elem -> MapExprElem
  : map_syntax_key ":" expr { 
    MapExprElem::{
      key: $1,
      expr: $3,
      key_loc: mk_loc($loc($1)),
      loc: mk_loc($sloc)
    }
  }
  ;

pattern -> Pattern
  : pattern "as" binder { @syntax.make_alias_pattern(loc = mk_loc($sloc), $1, $3) }
  | or_pattern { $1 }
  ;

or_pattern -> Pattern
  : range_pattern "|" or_pattern { Or(pat1 = $1, pat2 = $3, loc = mk_loc($sloc)) }
  | range_pattern { $1 }
  ;

range_pattern -> Pattern
  : simple_pattern "..<" simple_pattern { Range(lhs = $1, rhs = $3, inclusive = false, loc = mk_loc($sloc)) }
  | simple_pattern "..=" simple_pattern { Range(lhs = $1, rhs = $3, inclusive = true, loc = mk_loc($sloc)) }
  | simple_pattern { $1 }
  ;

simple_pattern -> Pattern
  : TRUE { @syntax.make_constant_pattern(loc = mk_loc($sloc), Bool(true)) }
  | FALSE { @syntax.make_constant_pattern(loc = mk_loc($sloc), Bool(false)) }
  | CHAR { @syntax.make_constant_pattern(loc = mk_loc($sloc), Char($1)) }
  | INT { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_int($1)) }
  | BYTE { @syntax.make_constant_pattern(loc = mk_loc($sloc), Byte($1)) }
  | DOUBLE { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_double($1)) }
  | FLOAT { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_float($1)) }
  | "-" INT { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_int("-" + $2)) }
  | "-" DOUBLE { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_double("-" + $2)) }
  | "-" FLOAT { @syntax.make_constant_pattern(loc = mk_loc($sloc), @syntax.make_float("-" + $2)) }
  | STRING { @syntax.make_constant_pattern(loc = mk_loc($sloc), String($1)) }
  | BYTES { @syntax.make_constant_pattern(loc = mk_loc($sloc), Bytes($1)) }
  | UNDERSCORE { Any(loc = mk_loc($sloc)) }
  | binder { Var($1) }
  | constr option(delimited("(", constr_pat_arguments, ")")) { 
    let (args, is_open) = match $2 {
      None => (None, false)
      Some((args, is_open)) => (Some(args), is_open)
    }
    @syntax.make_constr_pattern(loc = mk_loc($sloc), $1, args, is_open)
  }
  | "(" pattern ")" { $2 }
  | "(" pattern "," non_empty_list_commas(pattern) ")" { @syntax.make_tuple_pattern(loc = mk_loc($sloc), $4.add($2)) }
  | "(" pattern annot ")" { Constraint(pat = $2, ty = $3, loc = mk_loc($sloc)) }
  | "[" array_sub_patterns "]" { Array(pats = $2, loc = mk_loc($sloc)) }
  | "{" "}" { Record(fields = @list.empty(), is_closed = true, loc = mk_loc($sloc)) }
  | "{" ".." option(",") "}" { Record(fields = @list.empty(), is_closed = false, loc = mk_loc($sloc)) }
  | "{" non_empty_fields_pat "}" { 
    let (fields, is_closed) = $2
    Record(fields~, is_closed~, loc = mk_loc($sloc))
  }
  | "{" non_empty_map_elems_pat "}" { 
    let (elems, is_closed) = $2
    Map(elems~, is_closed~, loc = mk_loc($sloc))
  }
  ;

array_sub_pattern -> ArrayPattern
  : pattern { Pattern($1) }
  | ".." STRING { StringSpread($2) }
  | ".." BYTES { BytesSpread($2) }
  | ".." UIDENT { 
    let binder = Binder::{ name: $2, loc: mk_loc($loc($2)) }
    ConstSpread(binder~, pkg = None, loc = mk_loc($sloc))
  }
  | ".." PACKAGE_NAME DOT_UIDENT { 
    let binder = Binder::{ name: $3, loc: mk_loc($loc($3)) }
    ConstSpread(binder~, pkg = Some($2), loc = mk_loc($sloc))
  }
  ;

dotdot_binder -> DotDotBinder
  : ".." binder { Binder($2) }
  | ".." "_" { Underscore }
  | ".." "as" binder { BinderAs($3) }
  | ".." { NoBinder }
  ;

array_sub_patterns -> ArrayPatterns
  :  { Closed(@list.empty()) }
  | array_sub_pattern { Closed(@list.singleton($1)) }
  | array_sub_pattern "," array_sub_patterns { 
    match $3 {
      Closed(ps) => Closed(ps.add($1))
      Open(ps1, ps2, b) => Open(ps1.add($1), ps2, b)
    }
  }
  | dotdot_binder "," non_empty_list_commas(array_sub_pattern) { Open(@list.empty(), $3, $1) }
  | dotdot_binder ioption(",") { Open(@list.empty(), @list.empty(), $1) }
  ;

error_annotation -> ErrorType
  : "raise" { DefaultErrorType(loc = mk_loc($sloc)) }
  | "raise" error_type { ErrorType(ty = $2) }
  | "noraise" { Noraise(loc = mk_loc($sloc)) }
  | "raise" "?" { 
    let fake_error = Type::Name(
      constr_id = ConstrId::{ id: Ident(name = "Error"), loc: mk_loc($sloc) },
      tys = @list.empty(),
      loc = mk_loc($sloc)
    )
    MaybeError(ty = fake_error)
  }
  ;

return_type -> (Type, ErrorType)
  : type_ { ($1, NoErrorType) }
  | simple_type "!" { ($1, DefaultErrorType(loc = mk_loc($loc($2)))) }
  | simple_type "!" error_type { ($1, ErrorType(ty = $3)) }
  | simple_type "?" error_type { ($1, MaybeError(ty = $3)) }
  | simple_type error_annotation { ($1, $2) }
  ;

func_return_type -> (Type?, ErrorType)
  : "->" return_type { 
    match $2 {
      (ty, err) => (Some(ty), err)
    }
  }
  | error_annotation { (None, $1) }
  |  { (None, NoErrorType) }
  ;

error_type -> Type
  : qual_ident_ty { 
    Name(
      constr_id = ConstrId::{ id: $1, loc: mk_loc($sloc) },
      tys = @list.empty(),
      loc = mk_loc($sloc)
    )
  }
  | "_" { Any(loc = mk_loc($sloc)) }
  ;

simple_type -> Type
  : simple_type "?" { @syntax.make_option_type(loc = mk_loc($sloc), constr_loc = mk_loc($loc($2)), $1) }
  | "(" type_ "," non_empty_list_commas(type_) ")" { @syntax.make_tuple_type(loc = mk_loc($sloc), $4.add($2)) }
  | "(" type_ ")" { $2 }
  | qual_ident_ty_inline optional_type_arguments %prec prec_lower_than_as { 
    Name(
      constr_id = ConstrId::{ id: $1, loc: mk_loc($loc($1)) },
      tys = $2,
      loc = mk_loc($sloc)
    )
  }
  | "&" qual_ident_ty { Object(ConstrId::{ id: $2, loc: mk_loc($loc($2)) }) }
  | "_" { Any(loc = mk_loc($sloc)) }
  ;

type_ -> Type
  : simple_type { $1 }
  | is_async "(" type_ "," ioption(non_empty_list_commas(type_)) ")" "->" return_type { 
    let (ty_res, ty_err) = $8
    let ts = match $5 { 
      None => @list.empty() 
      Some(ts) => ts 
    }
    Arrow(args = ts.add($3), res = ty_res, err = ty_err, is_async = $1, loc = mk_loc($sloc))
  }
  | is_async "(" ")" "->" return_type { 
    let (ty_res, ty_err) = $5
    Arrow(args = @list.empty(), res = ty_res, err = ty_err, is_async = $1, loc = mk_loc($sloc))
  }
  | is_async "(" type_ ")" "->" return_type { 
    let (ty_res, ty_err) = $6
    Arrow(args = @list.singleton($3), res = ty_res, err = ty_err, is_async = $1, loc = mk_loc($sloc))
  }
  ;

record_decl_field -> FieldDecl
  : attributes visibility option("mut") LIDENT ":" type_ { 
    FieldDecl::{
      name: FieldName::{ label: $4, loc: mk_loc($loc($4)) },
      ty: $6,
      mut_: $3 is Some(_),
      vis: $2,
      loc: mk_loc($sloc),
      attrs: $1,
      doc: DocString::empty()
    }
  }
  ;

constructor_param -> ConstrParam
  : option("mut") type_ { 
    ConstrParam::{
      ty: $2,
      mut_: $1 is Some(_),
      label: None
    }
  }
  | option("mut") POST_LABEL ":" type_ { 
    let label = Label::{ name: $2, loc: mk_loc($loc($2)).trim_last_char() }
    ConstrParam::{
      ty: $4,
      mut_: $1 is Some(_),
      label: Some(label)
    }
  }
  ;

enum_constructor -> ConstrDecl
  : attributes UIDENT option(delimited("(", non_empty_list_commas(constructor_param), ")")) option(eq_int_tag) { 
    ConstrDecl::{
      name: ConstrName::{ name: $2, loc: mk_loc($loc($2)) },
      args: $3,
      tag: $4,
      loc: mk_loc($sloc),
      attrs: $1,
      doc: DocString::empty()
    }
  }
  ;

%inline eq_int_tag -> (String, Location)
  : "=" INT { ($2, mk_loc($loc($2))) }
  ;

record_defn -> (List[FieldDef], TrailingMark)
  : label_pun "," list_commas_with_trailing_info(record_defn_single) { 
    let (fs, trailing) = $3
    let trailing_mark = if fs.is_empty() || trailing { TrailingMark::Comma } else { TrailingMark::None }
    (fs.add($1), trailing_mark)
  }
  | labeled_expr option(",") { 
    let trailing_mark = if $2 is Some(_) { TrailingMark::Comma } else { TrailingMark::None }
    (@list.singleton($1), trailing_mark)
  }
  | labeled_expr "," non_empty_list_commas_with_trailing_info(record_defn_single) { 
    let (fs, trailing) = $3
    let trailing_mark = if trailing { TrailingMark::Comma } else { TrailingMark::None }
    (fs.add($1), trailing_mark)
  }
  ;

record_defn_single -> FieldDef
  : labeled_expr { $1 }
 | label_pun { $1 }
  ;

%inline labeled_expr -> FieldDef
  : label ":" expr { @syntax.make_field_def(loc = mk_loc($sloc), $1, $3, false) }
  ;

%inline label_pun -> FieldDef
  : label { @syntax.make_field_def(loc = mk_loc($sloc), $1, @syntax.label_to_expr(loc = mk_loc($sloc), $1), true) }
  ;

non_empty_fields_pat -> (List[FieldPat], Bool)
  : non_empty_list_commas(fields_pat_single) { ($1, true) }
  | non_empty_list_commas_with_tail(fields_pat_single) ".." option(",") { ($1, false) }
  ;

fields_pat_single -> FieldPat
  : fpat_labeled_pattern { $1 }
 | fpat_label_pun { $1 }
  ;

%inline fpat_labeled_pattern -> FieldPat
  : label ":" pattern { @syntax.make_field_pat(loc = mk_loc($sloc), $1, $3, false) }
  ;

%inline fpat_label_pun -> FieldPat
  : label { @syntax.make_field_pat(loc = mk_loc($sloc), $1, @syntax.label_to_pat(loc = mk_loc($sloc), $1), true) }
  ;

non_empty_map_elems_pat -> (List[MapPatElem], Bool)
  : non_empty_list_commas(map_elem_pat) { ($1, true) }
  | non_empty_list_commas_with_tail(map_elem_pat) ".." option(",") { ($1, false) }
  ;

%inline map_elem_pat -> MapPatElem
  : map_syntax_key option("?") ":" pattern { 
    MapPatElem::{
      key: $1,
      pat: $4,
      match_absent: $2 is Some(_),
      key_loc: mk_loc($loc($1)),
      loc: mk_loc($sloc)
    }
  }
  ;

constr_pat_arguments -> (List[ConstrPatArg], Bool)
  : constr_pat_argument option(",") { (@list.singleton($1), false) }
  | ".." option(",") { (@list.empty(), true) }
  | constr_pat_argument "," constr_pat_arguments { 
    let (args, is_open) = $3
    (args.add($1), is_open)
  }
  ;

constr_pat_argument -> ConstrPatArg
  : label "=" pattern { 
    ConstrPatArg::{
      pat: $3,
      kind: Labelled($1)
    }
  }
  | POST_LABEL { 
    let loc = mk_loc($loc($1))
    let label = Label::{ name: $1, loc }
    let pat = @syntax.label_to_pat(loc = loc.trim_last_char(), label)
    ConstrPatArg::{
      pat,
      kind: LabelledPun(label)
    }
  }
  | pattern { 
    ConstrPatArg::{
      pat: $1,
      kind: Positional
    }
  }
  ;